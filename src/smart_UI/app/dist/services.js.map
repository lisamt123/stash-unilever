{"version":3,"file":"services.js","sources":["webpack:///app/src/services/services.js","webpack:///app/src/services/apex-abstraction_core.js","webpack:///app/src/services/apex-abstraction_bl.js","webpack:///app/src/ui/calculationgrid/tree.js","webpack:///app/src/ui/benchmark.js","webpack:///app/src/ui/calculationgrid/MetaParser.js","webpack:///app/src/ui/calculationgrid/ArrayReducer.js","webpack:///app/src/ui/calculationgrid/CalcHelper.js","webpack:///app/src/ui/calculationgrid/TreeBuilder.js","webpack:///app/src/ui/calculationgrid/TreeNode.js","webpack:///app/src/ui/calculationgrid/ManualChangesSerializer.js","webpack:///app/src/ui/calculationgrid/CalculationVariableParser.js"],"sourcesContent":["\"use strict\";\r\n\r\n\r\nglobal.ErrorHandler =  require('./apex-abstraction_core').ErrorHandler;\r\nglobal.APEXAbstraction = require('./apex-abstraction_bl');\r\nglobal.Tree = require(\"../ui/calculationgrid/tree.js\");\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// app/src/services/services.js","'use strict';\r\n\r\nmodule.exports = apexAbstractionCore;\r\n\r\nfunction apexAbstractionCore() {\r\n}\r\n\r\napexAbstractionCore.prototype = {\r\n    invokeRemoteCall: function (method, extension, managed, compressed, buffer, isManagedObject, ...args) {\r\n        var startTime = new Date();\r\n        var me = this;\r\n        var result = when.defer();\r\n\r\n        var transactionId = Utils.guid();\r\n        const remoteCall = (ACSFNamespace && managed) ? ACSFNamespace + '.' + extension + '.' + method : extension + '.' + method;\r\n        // TODO: Check this syntax once UI is running. Should solve the namespace issue\r\n        //const remoteCall = '{!$RemoteAction.' + extension + '.' + method + className + '}';\r\n\r\n        var callback = function (callResult, event) {\r\n            var rex = /[A-Z]/g;\r\n\r\n            console.log(callResult,event);\r\n            if (event.status) {\r\n                //  result.resolve({'__Model': className, '__Status': event.status, 'data': callResult});\r\n                if (!compressed) {\r\n                    if (isManagedObject)\r\n                        callResult = AppManager.removeACSFNamespace(callResult);\r\n                    LogManager.getLogger(\"APEXAbstraction\").info({txid: transactionId}, \"END: RemoteCall: \", remoteCall, \"==> Duration \", new Date() - startTime, \" ms\", callResult);\r\n\r\n                    result.resolve({\r\n                        '__Model': event.method.substring(rex.exec(event.method).index),\r\n                        '__Status': event.status,\r\n                        'data': callResult\r\n                    });\r\n                }\r\n                else {\r\n                    me.readPagedResponse(callResult).then(pagedResult => {\r\n                        try {\r\n                            if (isManagedObject)\r\n                                callResult = AppManager.removeACSFNamespace(pagedResult);\r\n                            LogManager.getLogger(\"APEXAbstraction\").info({txid: transactionId}, \"END: RemoteCall: \", remoteCall, \"==> Duration \", new Date() - startTime, \" ms\", callResult);\r\n\r\n                            result.resolve({\r\n                                '__Model': event.method.substring(rex.exec(event.method).index),\r\n                                '__Status': event.status,\r\n                                'data': callResult\r\n                            });\r\n                        }\r\n                        catch (e) {\r\n                            ExceptionHandler.treatJSError(e);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                //result.resolve({'__Model': className, '__Status': event.status, 'ExceptionType': event.type, 'ExceptionMessage': event.message, 'ExceptionWhere': event.where});\r\n                ExceptionHandler.treatJSError(event);\r\n                LogManager.getLogger(\"APEXAbstraction\").error({txid: transactionId}, \"Exception: RemoteCall: \", remoteCall, event.action, event.method, event.message, event.data);\r\n                result.resolve({\r\n                    '__Model': event.action,\r\n                    '__Status': event.status,\r\n                    'ExceptionType': event.type,\r\n                    'ExceptionMessage': event.message,\r\n                    'ExceptionWhere': event.where\r\n                });\r\n            }\r\n        };\r\n        if (isManagedObject)\r\n            args = args.map(param=> {\r\n                return AppManager.addACSFNamespace(param);\r\n            });\r\n\r\n        LogManager.getLogger(\"APEXAbstraction\").info({txid: transactionId}, \"START: RemoteCall: \", remoteCall, \", Managed: \", managed, \", Compressed:\", compressed, \", Buffer:\", buffer, \", isManagedObject\", isManagedObject);\r\n\r\n        var logError = console.error;\r\n        console.error = error => {\r\n            ExceptionHandler.treatJSError(error);\r\n            result.reject(error);\r\n        };\r\n\r\n        if($VFRM.last) $VFRM.last.setTimeout = request => request.timeout = 1e7;\r\n        Visualforce.remoting.Manager.invokeAction(remoteCall, transactionId, ...args, callback, {\r\n            escape: false,\r\n            buffer: buffer\r\n        });\r\n\r\n        console.error = logError;\r\n\r\n        return result.promise;\r\n    },\r\n\r\n    readPagedResponse: function (response) {\r\n        var result = when.defer();\r\n        var startTime = new Date();\r\n        var method = \"getMessageContinuation\";\r\n        var extension = \"ContinuationRemoteActionExtension\";\r\n        var firstMsg = JSON.parse(response);\r\n        var pages = firstMsg.pages;\r\n        var id = firstMsg.responseid;\r\n        var promises = [];\r\n\r\n        for (var i = 2; i <= pages; i++) {\r\n            promises.push(this.invokeRemoteCall(method, extension, true, false, false, true, id, i.toString()));\r\n        }\r\n\r\n        when.all(promises).then(function (dataArray) {\r\n            LogManager.getLogger(\"APEXAbstraction\").info(\"Reading \", pages, \"from cache\", id, \"==> Duration \", new Date() - startTime, \" ms\");\r\n            var msgs = dataArray.map(function (data) {\r\n                return JSON.parse(data.data).response;\r\n            });\r\n            msgs.unshift(firstMsg.response);\r\n            Utils.Zip.unzip(msgs).then(uncompressedMsg => {\r\n                result.resolve(uncompressedMsg);\r\n            });\r\n        });\r\n\r\n        return result.promise;\r\n    },\r\n\r\n    read: function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n        var loadParams = (objectId instanceof Object) ? JSON.stringify(objectId) : objectId;\r\n        return this.invokeRemoteCall('read' + className, extension, managed, compressed, buffer, isManagedObject, loadParams);\r\n    },\r\n\r\n    readAll: function (className, extension, managed, compressed, buffer) {\r\n        return this.invokeRemoteCall('readAll' + className, extension);\r\n    },\r\n\r\n    write: function (objectId, objectContent, className, extension, managed, compressed, buffer, isManagedObject) {\r\n        return this.invokeRemoteCall('write' + className, extension, managed, compressed, buffer, isManagedObject, objectId, objectContent);\r\n    },\r\n\r\n    create: function (objectContent, className, extension, managed, compressed, buffer, isManagedObject) {\r\n        return this.invokeRemoteCall('create' + className, extension, managed, compressed, buffer, isManagedObject, objectContent);\r\n    },\r\n\r\n    delete: function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n        return this.invokeRemoteCall('delete' + className, extension, managed, compressed, buffer, isManagedObject, objectId);\r\n    },\r\n\r\n    getEARights: function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n        var loadParams = (objectId instanceof Object) ? JSON.stringify(objectId) : objectId;\r\n        return this.invokeRemoteCall('getEARights' + className, extension, managed, compressed, buffer, isManagedObject, loadParams);\r\n    },\r\n    copy : function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n    return this.invokeRemoteCall('copy' + className, extension, managed, compressed, buffer, isManagedObject, objectId);\r\n},\r\n\r\ngetData : function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n    return this.invokeRemoteCall('getData' + className, extension, managed, compressed, buffer, isManagedObject, objectId);\r\n},\r\n\r\ngetMeta : function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n    return this.invokeRemoteCall('getMeta' + className, extension, managed, compressed, buffer, isManagedObject, objectId);\r\n},\r\n    /**/\r\n    // Helper methods. Not related to any business object.\r\n    // Should maybe be moved into a separate class. For the moment they recide here, however\r\n    /*readContractById: function (classNames) {\r\n     var contractPromise = when.defer();\r\n     this.invokeRemoteCall('readContractById', 'ContractRemoteActionExtension', classNames).then(contracts => {\r\n     var contractArray = [];\r\n     contracts.forEach(function(contract) {\r\n     contractArray.push(JSON.parse(contract));\r\n     });\r\n     contractPromise.resolve(contractArray);\r\n     });\r\n     return contractPromise;\r\n     },\r\n     readBaseclassById: function (baseClassName, blObject, methods) {\r\n     var methodPromise = when.defer();\r\n     this.invokeRemoteCall('readContractById', 'ContractRemoteActionExtension', baseClassName).then(classString => {\r\n     this.eval(baseClassContent);\r\n     methods.forEach(function (method) {\r\n     blObject.Methods[method.Name] = this[baseClass][method.Name];\r\n     });\r\n     methodPromise.resolve(true);\r\n     });\r\n     return methodPromise.promise;\r\n     },*/\r\n\r\n  \r\n    readCustomLabels: function (labelCategory) {\r\n        var customLabelsAPEX = AppManager.getCustomLabelsApex();\r\n        return this.invokeRemoteCall(customLabelsAPEX.Type, customLabelsAPEX.Extension, customLabelsAPEX.Managed, customLabelsAPEX.Compressed, customLabelsAPEX.Buffer, true, labelCategory);\r\n    },\r\n\r\n    getLocale: function () {\r\n        var localeAPEX = AppManager.getLocaleApex();\r\n        return this.invokeRemoteCall(localeAPEX.Type, localeAPEX.Extension, localeAPEX.Managed, localeAPEX.Compressed, localeAPEX.Buffer, true);\r\n    },\r\n\r\n    getMetaData: function (boName, sfObjectName, isExternal, isManagedObject) {\r\n        var metaDataAPEX = AppManager.getMetaDataApex(),\r\n            promise,deferred,i;\r\n\r\n        if(metaDataAPEX.Aggregation === false){\r\n            promise = this.invokeRemoteCall(metaDataAPEX.Type, metaDataAPEX.Extension, metaDataAPEX.Managed, metaDataAPEX.Compressed, metaDataAPEX.Buffer, isManagedObject, boName, sfObjectName, isExternal);\r\n        }else{\r\n\r\n            if(!this._metaDataBuffer){\r\n\r\n                deferred = when.defer();\r\n                this._metaDataBuffer = [];\r\n                this._metaDataPromise = deferred.promise;\r\n\r\n                setTimeout(() => {\r\n                    var list = this._metaDataBuffer;\r\n                    delete this._metaDataBuffer;\r\n                    delete this._metaDataPromise;\r\n                    deferred.resolve( this.getMetaDataList(list, isManagedObject) );\r\n                },10);\r\n\r\n            }\r\n\r\n            i = this._metaDataBuffer.length;\r\n            this._metaDataBuffer.push(arguments);\r\n            promise = this._metaDataPromise.then(result => ({\r\n                '__Model': result.__Model,\r\n                '__Status': result.__Status,\r\n                'data': result.data ? result.data[i].fields : null,\r\n                'ExceptionType': result.ExceptionType,\r\n                'ExceptionMessage': result.ExceptionMessage,\r\n                'ExceptionWhere': result.ExceptionWhere\r\n            }));\r\n\r\n        }\r\n\r\n        return promise.then(response => {\r\n            var hasPickLists = false;\r\n\r\n            var hasCheckoutFlagSet = (AppManager.getArtifact(\r\n                (AppManager.getArtifact(boName).Artifact || {}).DataSource\r\n            ).Artifact || {}).CheckLayout || false;\r\n\r\n            if(!response.data){\r\n                response.data = {fields: []};\r\n                return response;\r\n            }\r\n\r\n            for(let field of response.data.fields){\r\n                field.getPicklistValues = getPicklistValues;\r\n                field.recordTypes = {};\r\n                if(field.type == 'PICKLIST') hasPickLists = true;\r\n            }\r\n\r\n            if(!hasCheckoutFlagSet) return response;\r\n            if(!sfObjectName) return response;\r\n\r\n            if(hasPickLists){\r\n\r\n                let deferred = when.defer();\r\n\r\n                if(isManagedObject) sfObjectName = AppManager.addACSFNamespace(sfObjectName);\r\n                sforce.connection.describeLayout(sfObjectName, null, null, {\r\n                    onSuccess: result => deferred.resolve(result),\r\n                    onFailure: error => deferred.reject(error)\r\n                });\r\n\r\n                deferred.promise.then(layout => {\r\n                    var recordTypes = {};\r\n\r\n                    if(isManagedObject) layout = AppManager.removeACSFNamespace(layout);\r\n                    _.extend(response, layout);\r\n\r\n                    for(let mapping of getArray(layout.recordTypeMappings)){\r\n                        for(let picklist of getArray(mapping.picklistsForRecordType)){\r\n\r\n                            recordTypes[picklist.picklistName] = recordTypes[picklist.picklistName] || {};\r\n                            recordTypes[picklist.picklistName][mapping.recordTypeId] = picklist;\r\n                            for(let value of getArray(picklist.picklistValues)){\r\n                                value.active = value.active == 'true';\r\n                                value.defaultValue = value.defaultValue == 'true';\r\n                            }\r\n\r\n                        }\r\n                    }\r\n\r\n                    for(let field of response.data.fields){\r\n                        field.recordTypes = recordTypes[field.name] || {};\r\n                    }\r\n\r\n                });\r\n\r\n            }\r\n\r\n            return response;\r\n        });\r\n    },\r\n\r\n    getMetaDataList: function (list, isManagedObject) {\r\n        var metaDataAPEX = AppManager.getMetaDataListApex();\r\n        var query = [];\r\n        var args;\r\n\r\n        for(args of list) query.push({\r\n            businessObject: args[0],\r\n            sfObject: args[1],\r\n            isExternal: args[2]\r\n        });\r\n\r\n        return this.invokeRemoteCall(metaDataAPEX.Type, metaDataAPEX.Extension, metaDataAPEX.Managed, metaDataAPEX.Compressed, metaDataAPEX.Buffer, isManagedObject, JSON.stringify(query));\r\n    },\r\n\r\n    getLoggingConfig: function () {\r\n        return this.invokeRemoteCall('getLogConfig', \"LogRemoteActionExtension\", true, false, true, true);\r\n    },\r\n\r\n    writeLogs: function (logs) {\r\n        return this.invokeRemoteCall('writeLogs', \"LogRemoteActionExtension\", true, false, true, true, logs);\r\n    }\r\n};\r\n\r\nfunction getPicklistValues(recordTypeId){\r\n    return (this.recordTypes[recordTypeId] || this).picklistValues || [];\r\n}\r\n\r\nfunction getArray(arr){\r\n    if(arr instanceof Array) return arr;\r\n    return [arr];\r\n}\r\n\r\nvar ExceptionHandler = {\r\n    treatJSError: function (event) {\r\n        var msg = event.message || event + '';\r\n        UI_EVENT_BUS.put(EVENTS.UI_ERROR, {title: 'Service Error',  message:msg,   type:'E'});\r\n    }\r\n};\r\n\r\nmodule.exports.ExceptionHandler = ExceptionHandler;\r\n\n\n\n// WEBPACK FOOTER //\n// app/src/services/apex-abstraction_core.js","\r\nvar apexAbstractionCoreClass = require('./apex-abstraction_core');\r\n\r\nvar apexAbstractionBL = new apexAbstractionCoreClass();\r\n\r\n//unilever workflow function\r\napexAbstractionBL.invokeWF = function (objectId, wfState, jsonContent, className, extension, managed, compressed, buffer, isManagedObject) {\r\n    return this.invokeRemoteCall('invokeWf' + className, extension, managed, compressed, buffer, isManagedObject, objectId, wfState, jsonContent);\r\n};\r\n\r\napexAbstractionBL.CreatePush = function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n    return this.invokeRemoteCall('CreatePush' + className, extension, managed, compressed, buffer, isManagedObject, objectId);\r\n};\r\n\r\napexAbstractionBL.cleanUpPush = function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n    return this.invokeRemoteCall('cleanUpPush' + className, extension, managed, compressed, buffer, isManagedObject, objectId);\r\n};\r\n\r\napexAbstractionBL.finalizePush = function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n    return this.invokeRemoteCall('finalizePush' + className, extension, managed, compressed, buffer, isManagedObject, objectId);\r\n};\r\n\r\napexAbstractionBL.UpdateEnablePush = function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n    return this.invokeRemoteCall('UpdateEnablePush' + className, extension, managed, compressed, buffer, isManagedObject, objectId);\r\n};\r\n\r\napexAbstractionBL.validate = function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n    return this.invokeRemoteCall('validate' + className, extension, managed, compressed, buffer, isManagedObject, objectId);\r\n};\r\n\r\n//PMA - START CODE - 2017-01-13 - Threshold button\r\napexAbstractionBL.invokePromotionThresholdCheck = function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n    return this.invokeRemoteCall('invokePromotionThresholdCheck' + className, extension, managed, compressed, buffer, isManagedObject, objectId);\r\n};\r\napexAbstractionBL.invokeAuditTrail = function (objectId, className, extension, managed, compressed, buffer, isManagedObject) {\r\n    return this.invokeRemoteCall('invokeAuditTrail' + className, extension, managed, compressed, buffer, isManagedObject, objectId);\r\n};\r\n//PMA - END CODE - 2017-01-13 - Threshold button\r\n\r\nmodule.exports = apexAbstractionBL;\r\n\n\n\n// WEBPACK FOOTER //\n// app/src/services/apex-abstraction_bl.js","\"use strict\";\r\n/* globals CasException */\r\n\r\nif (typeof require !== \"undefined\") {\r\n    var _ = require(\"lodash\");\r\n    var bunyan = require('bunyan');\r\n    var benchmark = require('../benchmark');\r\n    var metaParser = require('./MetaParser');\r\n    var calcHelper = require('./CalcHelper');\r\n    var TreeBuilder = require('./TreeBuilder');\r\n    var TreeNode = require('./TreeNode');\r\n    var ManualChangesSerializer = require('./ManualChangesSerializer').ManualChangesSerializer;\r\n    var CalculationVariableParser = require('./CalculationVariableParser').CalculationVariableParser;\r\n}\r\n\r\nvar TOTAL_COLUMN_NAME = \"Total\";\r\n\r\nvar logger = bunyan.createLogger({\r\n    name: \"CasAnalytics\",\r\n    streams: [{\r\n        level: 'info',\r\n        stream: new MyRawStream(),\r\n        type: 'raw'\r\n    }]\r\n});\r\n\r\n/**\r\n *\r\n * @constructor\r\n */\r\nvar Tree = function () {\r\n    var log = logger.child({widget_type: 'Tree'});\r\n\r\n    var dataMeta = {};\r\n    var rootNode = null;\r\n    var helper = null;\r\n    var variables = null;\r\n    var manualChangesSerializer = null;\r\n\r\n    var meta = {};\r\n    var nodeCounter = 0;\r\n\r\n    /**\r\n     * Gets an instance of the serializer for manual changes\r\n     * @return {ManualChangesSerializer}\r\n     */\r\n    this.getManualChangesSerializer = function () {\r\n        if (manualChangesSerializer === null) {\r\n            manualChangesSerializer = new ManualChangesSerializer(dataMeta, meta, logger, benchmark);\r\n        }\r\n\r\n        return manualChangesSerializer;\r\n    };\r\n\r\n    /**\r\n     * Gets the MetaInformation of this Tree\r\n     * @returns {*}\r\n     */\r\n    this.getMeta = function () {\r\n        return meta;\r\n    };\r\n\r\n    /**\r\n     * gets the DataMeta Information of this Tree\r\n     * @returns {{}}\r\n     */\r\n    this.getDataMeta = function () {\r\n        return dataMeta;\r\n    };\r\n\r\n    this.getVariables = function () {\r\n        return variables;\r\n    };\r\n\r\n    /**\r\n     * Gets all lookup values of the specified column\r\n     * @param {string} dimensionName\r\n     * @returns {string[]}\r\n     */\r\n    function getLookupValues(dimensionName) {\r\n        //FixMe: Will only work on dimensions!\r\n        var values = [];\r\n        var dimension = _.find(dataMeta.dimensions, [\"name\", dimensionName]);\r\n        if (dimension !== undefined) {\r\n            if (dimension.type === \"time\") {\r\n                values = dimension.details;\r\n            }\r\n            else {\r\n                values = dimension.lookups;\r\n            }\r\n        }\r\n        else {\r\n            log.warn(\"Missing dimension named: \" + dimensionName + \"!\");\r\n        }\r\n\r\n        return values;\r\n    }\r\n\r\n    function processDimensionInformation() {\r\n        var measureDimension = _.find(dataMeta.dimensions, [\"type\", \"measure\"]);\r\n        if (measureDimension !== undefined) {\r\n            dataMeta.measureDimensionName = measureDimension.name;\r\n            dataMeta.isMeasureDimensionName = isMeasureDimensionName;\r\n        }\r\n        else {\r\n            throw new CasException.CasException(\"The Data does not contain a dimension of type 'measure'.\");\r\n        }\r\n\r\n        processTimeDimensionInformation();\r\n    }\r\n\r\n    function processTimeDimensionInformation() {\r\n        var timeDimension = _.find(dataMeta.dimensions, [\"type\", \"time\"]);\r\n\r\n        if (timeDimension !== undefined) {\r\n            dataMeta.today = (new Date()).setHours(0, 0, 0, 0);\r\n            dataMeta.timeDimensionName = timeDimension.name;\r\n            dataMeta.timeDetails = timeDimension.details;\r\n            dataMeta.noOfDataColumns = timeDimension.details.length + 1;\r\n\r\n            dataMeta.currentWeekIndex = -1;\r\n            for (var detailsIndex = 0; detailsIndex < timeDimension.details.length; detailsIndex++) {\r\n                var timeDetails = timeDimension.details[detailsIndex];\r\n                var dateFrom = new Date(timeDetails.datefrom);\r\n                var dateThru = new Date(timeDetails.datethru);\r\n\r\n                if (dateFrom <= dataMeta.today && dataMeta.today <= dateThru) {\r\n                    // correct week found (current week is today)\r\n                    dataMeta.currentWeekIndex = detailsIndex;\r\n                    break;\r\n                } else if (dateThru < dataMeta.today) {\r\n                    // current week lies in the past\r\n                    dataMeta.currentWeekIndex = detailsIndex + 1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            throw new CasException.CasException(\"The Data does not contain a dimension of type 'time'.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates if the given dimensionName is equal to the name of the measure dimension\r\n     * @param {string} dimensionName\r\n     * @return {boolean}\r\n     */\r\n    function isMeasureDimensionName(dimensionName) {\r\n        return (dataMeta.measureDimensionName === dimensionName);\r\n    }\r\n\r\n    function computeAllLevels(yAxis, dimensionsInformation) {\r\n        dataMeta.allLevels = [];\r\n        dataMeta.levelNameDimensionIndexMapping = {};\r\n        dataMeta.levelNameDimensionNameMapping = {};\r\n        dataMeta.dimensionByName = {};\r\n\r\n        for (var dimensionIndex = 0; dimensionIndex < yAxis.length; dimensionIndex++) {\r\n            var hierarchicalMapping = [];\r\n\r\n            var dimensionName = yAxis[dimensionIndex];\r\n            if (dimensionName === \"measures\") {\r\n                dimensionName = dataMeta.measureDimensionName;\r\n            }\r\n\r\n            var dimensionInfo = _.find(dimensionsInformation, [\"name\", dimensionName]);\r\n            if (dimensionInfo !== undefined) {\r\n                dataMeta.dimensionByName[dimensionName] = dimensionInfo;\r\n\r\n                do {\r\n                    dataMeta.levelNameDimensionIndexMapping[dimensionInfo.name] = dimensionIndex;\r\n                    dataMeta.levelNameDimensionNameMapping[dimensionInfo.name] = dimensionName;\r\n\r\n                    hierarchicalMapping.unshift(dimensionInfo.name);\r\n                    dimensionInfo = dimensionInfo.hierarchy;\r\n                } while (dimensionInfo !== undefined);\r\n\r\n                dataMeta.allLevels = _.concat(dataMeta.allLevels, hierarchicalMapping);\r\n            }\r\n            else {\r\n                throw new CasException.CasException(\"The dimension with the name \" + dimensionName + \" is not part of the data.\");\r\n            }\r\n        }\r\n\r\n        dataMeta.getLevelIndex = getLevelIndex;\r\n        dataMeta.getDimensionIndex = getDimensionIndex;\r\n        dataMeta.getDimensionName = getDimensionName;\r\n        dataMeta.getDimensionByName = getDimensionByName;\r\n    }\r\n\r\n    function getDimensionByName(dimensionName) {\r\n        if(dataMeta.dimensionByName[dimensionName] !== undefined) {\r\n            return dataMeta.dimensionByName[dimensionName];\r\n        } else {\r\n            throw new CasException.CasException(\"Cannot find the dimension with the name \" + dimensionName);\r\n        }\r\n    }\r\n\r\n    function getLevelIndex(levelName) {\r\n        var adjustedLevelName = levelName;\r\n        if(levelName === \"measures\") {\r\n            adjustedLevelName = dataMeta.measureDimensionName;\r\n        }\r\n        var levelIndex = _.indexOf(dataMeta.allLevels, adjustedLevelName);\r\n\r\n        if (levelIndex >= 0) {\r\n            return levelIndex;\r\n        }\r\n        else {\r\n            throw new CasException.CasException(\"Cannot find the level with the name \" + levelName);\r\n        }\r\n    }\r\n\r\n    function getDimensionIndex(levelName) {\r\n        if (levelName in dataMeta.levelNameDimensionIndexMapping) {\r\n            return dataMeta.levelNameDimensionIndexMapping[levelName];\r\n        }\r\n        else {\r\n            throw new CasException.CasException(\"Cannot identify the dimension of the level with the name \" + levelName);\r\n        }\r\n    }\r\n\r\n    function getDimensionName(levelName) {\r\n        if (levelName in dataMeta.levelNameDimensionNameMapping) {\r\n            return dataMeta.levelNameDimensionNameMapping[levelName];\r\n        }\r\n        else {\r\n            throw new CasException.CasException(\"Cannot identify the dimension of the level with the name \" + levelName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates and stores allHeaders\r\n     * Includes the TotalColumn if necessary\r\n     * @param {string} xAxis\r\n     * @param {string[]} yAxis\r\n     */\r\n    function computeAllHeaders(xAxis, yAxis) {\r\n        var xAxisValues = getLookupValues(xAxis);\r\n\r\n        meta.allHeaders = _.concat(yAxis, TOTAL_COLUMN_NAME, xAxisValues);\r\n        meta.dataColumnHeaders = _.concat(TOTAL_COLUMN_NAME, xAxisValues);\r\n    }\r\n\r\n    /**\r\n     * Loads all Data, Meta and Variables into the Tree\r\n     * @param {Object} data The data itself and information about the structure of the Data\r\n     * @param {number[][]} data.data The Data itself and the MetaData about the given Data\r\n     * @param {*} data.relations The Data itself and the MetaData about the given Data\r\n     * @param {Object[]} data.dimensions Collection of all dimensions information of the tableData\r\n     * @param {String} data.dimensions[].name Name of the Column\r\n     * @param {String[]} data.dimensions[].lookups 0-Indexed lookUp-Values for the tableData\r\n     * @param {Object} metaInfo Information about the resulting structure (ColumnOrder, CalculationFormulas,...)\r\n     * @param {Object} metaInfo.axis Information about the axis of the grid\r\n     * @param {string} metaInfo.axis.x Reference to the dimensions in data.dimensions\r\n     * @param {string[]} metaInfo.axis.y Reference to the dimensions in data.dimensions. Must include \"measures\" as KeyWord\r\n     * @param {Object[]} metaInfo.measures Collection of all measures of the grid\r\n     * @param {string} metaInfo.measures[].name Name of the measures (for displaying and as reference to columns if provided in data.data)\r\n     * @param {boolean} metaInfo.measures[].display Indicates if the measure shall be displayed or is only necessary for calculation\r\n     * @param {boolean} metaInfo.measures[].editable Indicates if this measure can be edited\r\n     * @param {boolean} metaInfo.measures[].writeBack Indicates if the edited values of this measure shall be persisted (only in use with editable=true)\r\n     * @param {boolean} metaInfo.measures[].computed Indicates if this measure must be calculated\r\n     * @param {string} metaInfo.measures[].formula Formula used for the calculation of this measure (only in use with computed=true), must be a valid JS-Function. Can reference measures and VARS\r\n     * @param {string} metaInfo.measures[].aggregation Instruction how to aggregate this measure (null|sum|min|max...)\r\n     * @param {string} metaInfo.measures[].totalCalculation Instruction how to aggregate the TotalColumn (null|sum|min|max...) (see meta.total.display)\r\n     * @param {Object} metaInfo.total Information if the TotalColumn should be calculated/displayed\r\n     * @param {boolean} metaInfo.total.display Indicates if the TotalColumn shall be calculated and displayed (see data.dimensions[].totalCalculation)\r\n     * @param {string} metaInfo.total.label Label to be displayed/returned for the TotalColumn\r\n     * @param {Array} vars Additional Variables as Key-Value-Pairs (used for calculation)\r\n     * @param {Object} manualChanges\r\n     */\r\n    this.loadData = function (data, metaInfo, vars, manualChanges) {\r\n        benchmark.startMeasurement('loadData');\r\n        log.trace(\"loadData() - Start\");\r\n    \r\n        log.trace(\"Parsing Variables\");\r\n        var startDate = Date.now();\r\n        var variableParser = new CalculationVariableParser();\r\n        variableParser.setBenchmark(benchmark);\r\n        variableParser.setLogger(log);\r\n    \r\n        variableParser.parse(vars);\r\n        variables = vars;\r\n        log.trace(\"Parsing Variables done: \" + (Date.now() - startDate));\r\n    \r\n        log.trace(\"Parsing Meta:\");\r\n        startDate = Date.now();\r\n        meta = metaParser.parseMeta(metaInfo);\r\n        log.trace(\"Parsing Meta done: \" + (Date.now() - startDate));\r\n    \r\n        dataMeta.dimensions = data.dimensions;\r\n        dataMeta.relations = data.relations;\r\n        \r\n        log.trace(\"processDimensionInformation:\");\r\n        startDate = Date.now();\r\n        processDimensionInformation();\r\n        log.trace(\"processDimensionInformation done: \" + (Date.now() - startDate));\r\n    \r\n        log.trace(\"computeAllLevels:\");\r\n        startDate = Date.now();\r\n        computeAllLevels(meta.axis.y, data.dimensions);\r\n        log.trace(\"computeAllLevels done: \" + (Date.now() - startDate));\r\n    \r\n        log.trace(\"computeAllHeaders:\");\r\n        startDate = Date.now();\r\n        computeAllHeaders(meta.axis.x, meta.axis.y);\r\n        log.trace(\"computeAllHeaders done: \" + (Date.now() - startDate));\r\n    \r\n        helper = new calcHelper.CalcHelper(meta, dataMeta, vars, log);\r\n    \r\n        TreeNode.setCalcHelper(helper);\r\n        TreeNode.setLogger(log);\r\n        TreeNode.setDataMeta(dataMeta);\r\n        TreeNode.setMeta(meta);\r\n    \r\n        log.trace(\"getTreeBuilder:\");\r\n        startDate = Date.now();\r\n        var treeBuilder = this.getTreeBuilder(data);\r\n        log.trace(\"getTreeBuilder done: \" + (Date.now() - startDate));\r\n        \r\n        log.trace(\"buildTree:\");\r\n        startDate = Date.now();\r\n        this.buildTree(treeBuilder);\r\n        log.trace(\"buildTree done: \" + (Date.now() - startDate));\r\n    \r\n        log.trace(\"fillTree:\");\r\n        startDate = Date.now();\r\n        this.fillTree(data.data);\r\n        log.trace(\"fillTree done: \" + (Date.now() - startDate));\r\n    \r\n        log.trace(\"applyManualChanges:\");\r\n        startDate = Date.now();\r\n        this.applyManualChanges(manualChanges);\r\n        log.trace(\"applyManualChanges done: \" + (Date.now() - startDate));\r\n    \r\n        log.trace(\"loadData() - End\");\r\n        benchmark.endMeasurement('loadData');\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * @memberOf Tree\r\n     */\r\n    this.applyManualChanges = function applyManualChanges(manualChanges) {\r\n        log.debug(\"Applying manual changes\");\r\n        benchmark.startMeasurement(\"applyManualChanges\");\r\n        var deserializedChanges = {};\r\n\r\n        var serializer = this.getManualChangesSerializer();\r\n\r\n        if (serializer.isValid(manualChanges)) {\r\n            deserializedChanges = serializer.deserialize(manualChanges);\r\n        }\r\n        else {\r\n            log.debug(\"No valid manual changes found\");\r\n        }\r\n\r\n        if (deserializedChanges.length > 0) {\r\n            var rootNode = this.getRootNode();\r\n\r\n            for (var changeIndex = 0; changeIndex < deserializedChanges.length; changeIndex++) {\r\n                var change = deserializedChanges[changeIndex];\r\n                var currentNode = rootNode.getNode(change.path);\r\n\r\n                if (currentNode !== undefined) {\r\n                    currentNode.set(change.columnIndex, change.value);\r\n                }\r\n                else {\r\n                    log.info(\"Could not apply a change. As the path could not be resolved\");\r\n                }\r\n            }\r\n\r\n            log.debug(\"Applied \" + deserializedChanges.length + \" manual changes\");\r\n        }\r\n        else {\r\n            log.debug(\"No changes to be applied\");\r\n        }\r\n\r\n        benchmark.endMeasurement(\"applyManualChanges\");\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * @memberOf Tree\r\n     * @param {[][]}data\r\n     */\r\n    this.fillTree = function fillTree(data) {\r\n        log.debug(\"Filling the Tree\");\r\n        benchmark.startMeasurement(\"fillTree\");\r\n        this.fillTreeNode(this.getRootNode(), data, 0);\r\n        benchmark.endMeasurement(\"fillTree\");\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     * @memberOf Tree\r\n     * @param {TreeNode} parentNode\r\n     * @param {[][]} data\r\n     * @param {number} dimensionIndex\r\n     */\r\n    this.fillTreeNode = function fillTreeNode(parentNode, data, dimensionIndex) {\r\n        // getName of the dimension (Tactic/measures/Prd,...)\r\n        var dimensionName = meta.axis.y[dimensionIndex];\r\n        var correctedDimensionName = dimensionName;\r\n        if (dimensionName === \"measures\") {\r\n            correctedDimensionName = dataMeta.measureDimensionName;\r\n        }\r\n\r\n        // get Dimension via its name from dataMeta.dimensions.find(\r\n        var dataMetaDimensionIndex = _.findIndex(dataMeta.dimensions, {\"name\": correctedDimensionName});\r\n        var dataMetaDimension = dataMeta.dimensions[dataMetaDimensionIndex];\r\n\r\n        for (var nodeId = -1; nodeId < dataMetaDimension.lookups.length; nodeId++) {\r\n            var correctedNodeId = nodeId;\r\n            if (dimensionName === \"measures\") {\r\n                correctedNodeId = _.findIndex(meta.measures, [\"name\", dataMetaDimension.lookups[nodeId]]);\r\n            }\r\n\r\n            // get only this part of the data where the value {nodeId} on the index {dataMetaDimensionIndex} matches\r\n            var partitionedData = _.partition(data, [dataMetaDimensionIndex, nodeId]);\r\n            var dimensionData = partitionedData[0];\r\n            data = partitionedData[1];\r\n\r\n            if (dimensionData.length > 0) {\r\n\r\n                var node = this.getDimensionNode(parentNode, correctedNodeId, dataMetaDimension.hierarchy);\r\n\r\n                if (node.isLeaf()) {\r\n                    var dataIndex = _.findIndex(dataMeta.dimensions, [\"name\", meta.axis.x]);\r\n                    var rawData = dimensionData[0][dataIndex]; // check if here a check is necessary due to missing data\r\n\r\n                    node.setRawData(rawData);\r\n                }\r\n                else {\r\n                    this.fillTreeNode(node, dimensionData, dimensionIndex + 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (data.length > 0) {\r\n            log.warn(\"fillTreeNode: Could not set all data. Remaining data: \" + JSON.stringify(data));\r\n        }\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {Object} hierarchy\r\n     * @param {string} hierarchy.name\r\n     * @param {Object|undefined} hierarchy.hierarchy\r\n     * @param {string[]} hierarchy.lookups\r\n     * @param {string} oldLevel\r\n     * @param {SimpleTree} filters\r\n     * @param {Object[]} allLevels\r\n     * @param {number} dimensionIndex\r\n     * @param {number} hierarchyIndex\r\n     * @return {string}\r\n     */\r\n    this.getLevelsForTreeBuilder = function (hierarchy, oldLevel, filters, allLevels, dimensionIndex, hierarchyIndex) {\r\n        var newLevel = hierarchy.name;\r\n        if (hierarchy.hierarchy !== undefined && hierarchy.hierarchy.lookups !== undefined) {\r\n            oldLevel = this.getLevelsForTreeBuilder(hierarchy.hierarchy, oldLevel, filters, allLevels, dimensionIndex, hierarchyIndex + 1);\r\n            var levels = [oldLevel, newLevel];\r\n            var mapping = [1, 0];\r\n            var filter = TreeBuilder.addIndex(hierarchy.hierarchy.mapping);\r\n            filters.push(TreeBuilder.createFilterTree(filter, mapping, levels));\r\n        }\r\n        var lookups = hierarchy.lookups;\r\n        var level = {};\r\n        level.startIndex = newLevel === dataMeta.measureDimensionName || hierarchyIndex > 0 ? 0 : -1;\r\n        level.endIndex = lookups.length - 1;\r\n        level.dimensionIndex = dimensionIndex;\r\n        level.hierarchyIndex = hierarchyIndex;\r\n        level.name = newLevel;\r\n        allLevels.push(level);\r\n        return newLevel;\r\n    };\r\n\r\n    /**\r\n     * gets all filters to build up the tree\r\n     * @param data response from the web service with the data\r\n     */\r\n    this.getTreeBuilder = function (data) {\r\n        // dimension info\r\n        var measureDimensionName = dataMeta.measureDimensionName;\r\n        var filters = [];\r\n        var allLevels = [];\r\n        var oldLevel = \"ROOT\";\r\n        //for (var dimIndex in dimensions) {\r\n        for (var i = 0; i < meta.axis.y.length; i++) {\r\n            var dimName = meta.axis.y[i];\r\n            if (dimName === \"measures\") {\r\n                dimName = measureDimensionName;\r\n            }\r\n            var dimension = dataMeta.getDimensionByName(dimName);\r\n            oldLevel = this.getLevelsForTreeBuilder(dimension, oldLevel, filters, allLevels, i, 0);\r\n        }\r\n\r\n        // relations:\r\n        var relations = data.relations;\r\n        for (var relIndex = 0; relIndex < relations.length; relIndex++) {\r\n            var relation = relations[relIndex];\r\n            if (relation === undefined) {\r\n                continue;\r\n            } else {\r\n                var levels = relation.dimensions;\r\n                var filter = relation.mapping;\r\n                var mapping = levels.map(\r\n                    function (name, index) {\r\n                        return index;\r\n                    });\r\n                filters.push(TreeBuilder.createFilterTree(filter, mapping, levels));\r\n            }\r\n        }\r\n\r\n        // fix number of measures\r\n        // Do not delete. Still in use: Needs to be optimized!\r\n        var measures = meta.measures;\r\n        var measureLevel = _.find(allLevels, {\"name\": measureDimensionName});\r\n        measureLevel.endIndex = measures.length - 1;\r\n\r\n        // implicite relations\r\n        for (var i = 0; i < meta.axis.y.length; i++) {\r\n            var dimName = meta.axis.y[i];\r\n            if (dimName === \"measures\") {\r\n                continue;\r\n            } else {\r\n                var dimension = dataMeta.getDimensionByName(dimName);\r\n                var levels = [measureDimensionName, dimension.name];\r\n                var mapping = [0, 1];\r\n                var filter = [];\r\n                for(var measureIndex = 0; measureIndex < measures.length; measureIndex++) {\r\n                    var measure = measures[measureIndex];\r\n                    if(measure.isDimensionSkipped(i)) {\r\n                        filter.push([measureIndex, -1]);  // only the imaginary item\r\n                    }\r\n                    else {\r\n                        for(var itemIndex = 0; itemIndex < dimension.lookups.length; itemIndex++) {  // all real items\r\n                            filter.push([measureIndex, itemIndex]);\r\n                        }\r\n                    }\r\n                }\r\n                filters.push(TreeBuilder.createFilterTree(filter, mapping, levels));\r\n            }\r\n        }\r\n        return new TreeBuilder.TreeBuilder(0, allLevels, filters);\r\n    };\r\n\r\n    /**\r\n     * Builds up the entire tree\r\n     * @private\r\n     * @memberOf Tree\r\n     */\r\n    this.buildTree = function buildTree(treeBuilder) {\r\n        log.debug(\"Building the tree\");\r\n        benchmark.startMeasurement(\"buildTree\");\r\n\r\n        var globalId = nodeCounter++;\r\n        rootNode = new TreeNode.TreeNode(globalId, 0, -1, 0, -1, TreeNode._NodeTypes.ROOT, null, null, null);\r\n\r\n        this.createTreeNode(rootNode, 0, -1, null, treeBuilder);\r\n        benchmark.endMeasurement(\"buildTree\");\r\n        log.debug(\"Total number of Nodes: \" + nodeCounter);\r\n    };\r\n\r\n    var getHierarchyHeight = function (hierarchyInformation) {\r\n        if (hierarchyInformation === undefined) {\r\n            return -1;\r\n        }\r\n        else {\r\n            var parent = hierarchyInformation.hierarchy;\r\n            return getHierarchyHeight(parent) + 1;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Creates new TreeNodes recursively below the given parent including the hierarchy of the dimensions\r\n     * @private\r\n     * @memberOf Tree\r\n     * @param {TreeNode} parentNode\r\n     * @param {number} dimensionIndex\r\n     * @param {Object} hierarchyHeight\r\n     * @param {Object} measureDefinition\r\n     * @param {Object} treeBuilder\r\n     */\r\n    this.createTreeNode = function createTreeNode(parentNode, dimensionIndex, hierarchyHeight, measureDefinition, treeBuilder) {\r\n        var maxDimensionIndex = meta.axis.y.length - 1;\r\n        if (dimensionIndex > maxDimensionIndex) {\r\n            return;\r\n        }\r\n\r\n        // getName of the dimension (Tactic/measures/Prd,...)\r\n        var measureDimensionName = dataMeta.measureDimensionName;\r\n        var dimensionName = meta.axis.y[dimensionIndex];\r\n        if (dimensionName === \"measures\") {\r\n            dimensionName = measureDimensionName;\r\n        }\r\n        if (hierarchyHeight === -1) {\r\n            var dataMetaDimension = dataMeta.getDimensionByName(dimensionName);\r\n            hierarchyHeight = getHierarchyHeight(dataMetaDimension);\r\n        }\r\n        var isLeafLevel = (dimensionIndex === maxDimensionIndex && hierarchyHeight === 0);\r\n        var nodeType = (isLeafLevel) ? TreeNode._NodeTypes.LEAF : TreeNode._NodeTypes.GROUPING;\r\n\r\n        var measures;\r\n        if (dimensionName === measureDimensionName) {\r\n            measures = meta.measures;\r\n        }\r\n        var children = treeBuilder.getChildren();\r\n        var startIndex = hierarchyHeight > 0 ? 0 : -1;\r\n        for (var childId = startIndex; childId < children.length; childId++) {\r\n            var childTreeBuilder = children[childId];\r\n            if (childTreeBuilder) {\r\n                if (dimensionName === measureDimensionName) {\r\n                    measureDefinition = measures[childId];\r\n                }\r\n                var root = this.getRootNode();\r\n                var node = new TreeNode.TreeNode(nodeCounter++, childId, dimensionIndex, hierarchyHeight, parentNode.getLevel() + 1, nodeType, parentNode, root, measureDefinition);\r\n                node._data = new Array(dataMeta.noOfDataColumns);\r\n                _.fill(node._data, null);\r\n                if (nodeType === TreeNode._NodeTypes.LEAF) {\r\n                    parentNode.childAreLeafs = true;\r\n                }\r\n                if (isLeafLevel) {\r\n                    parentNode.addChild(node);\r\n                } else {\r\n                    if (hierarchyHeight === 0) {\r\n                        this.createTreeNode(node, dimensionIndex + 1, -1, measureDefinition, childTreeBuilder);\r\n                    } else {\r\n                        this.createTreeNode(node, dimensionIndex, hierarchyHeight - 1, measureDefinition, childTreeBuilder);\r\n                    }\r\n\r\n                    if (node._children[-1] || node._children.length > 0) {\r\n                        parentNode.addChild(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets a specific dimensionNode (steps through the hierarchy if necessary)\r\n     * @private\r\n     * @memberOf Tree\r\n     * @param {TreeNode} parentDimensionNode\r\n     * @param {number} childId\r\n     * @param {Object} hierarchyInformation\r\n     * @return {TreeNode|undefined}\r\n     */\r\n    this.getDimensionNode = function getDimensionNode(parentDimensionNode, childId, hierarchyInformation) {\r\n        var parentNode;\r\n\r\n        if (hierarchyInformation === undefined) {\r\n            parentNode = parentDimensionNode;\r\n        } else {\r\n            var hierarchyParentId = hierarchyInformation.mapping[childId];\r\n            parentNode = this.getDimensionNode(parentDimensionNode, hierarchyParentId, hierarchyInformation.hierarchy);\r\n        }\r\n\r\n        return parentNode.getChildNode(childId);\r\n    };\r\n\r\n    /**\r\n     * Gets the RootNode\r\n     * @public\r\n     * @returns {TreeNode}\r\n     */\r\n    this.getRootNode = function () {\r\n        return rootNode;\r\n    };\r\n\r\n    /**\r\n     * Gets a ChildNode via its global unique Id\r\n     * @param {number} globalId Id of the node to be searched\r\n     * @returns {TreeNode|null}\r\n     */\r\n    this.getChild = function (globalId) {\r\n        log.trace(\"getChild() - Start\");\r\n\r\n        var childNode = null;\r\n\r\n        if (globalId === 0) {\r\n            childNode = rootNode;\r\n        }\r\n        else {\r\n            childNode = getChildRecursive(rootNode, globalId);\r\n        }\r\n\r\n        log.trace(\"getChild() - End\");\r\n        return childNode;\r\n    };\r\n\r\n    /**\r\n     * Gets a ChildNode below its parentNode via its global unique Id\r\n     * @param {TreeNode} parentNode Starting Node\r\n     * @param {number} globalId Global unique Id of the node to be searched\r\n     * @returns {TreeNode|null} Node to be found or undefined\r\n     */\r\n    function getChildRecursive(parentNode, globalId) {\r\n        var childNode = null;\r\n        parentNode._children.forEach(function (child) {\r\n            if (child.id === globalId) {\r\n                childNode = child;\r\n            }\r\n            else if (!childNode) {\r\n                childNode = getChildRecursive(child, globalId);\r\n            }\r\n        });\r\n\r\n        return childNode;\r\n    };\r\n\r\n    /**\r\n     * Collection all WriteBack relevant rows and wor-Identifier\r\n     * @param {[]} result Collection of rows which shall be written back to the DB\r\n     * @param {Object} identifiers\r\n     * @param {TreeNode[]} nodes Collection of nodes which must be check if they are relevant for the writeBack\r\n     */\r\n    this.getWriteBackDataRecursive = function (result, identifiers, nodes) {\r\n        benchmark.startMeasurement('getWriteBackDataRecursive');\r\n\r\n        for (var i = -1; i < nodes.length; i++) {\r\n            var currentNode = nodes[i];\r\n\r\n            if (currentNode !== undefined) {\r\n                var measureDefinition = currentNode.getMeasureDefinition();\r\n                var dimensionId = currentNode.getDimensionId();\r\n                var dimensionName = meta.axis.y[dimensionId];\r\n                var currentIdentifiers = _.clone(identifiers);\r\n                if (dimensionName === \"measures\") {\r\n                    currentIdentifiers[dataMeta.measureDimensionName] = measureDefinition.storageOptions.code;\r\n                }\r\n                else {\r\n                    currentIdentifiers[dimensionName] = currentNode.getLabel();\r\n                }\r\n\r\n                if (measureDefinition !== null) {\r\n                    if (measureDefinition.storageOptions.writeBack === true) {\r\n                        if (_.find(measureDefinition.storageOptions.levels, [\"levelIndex\", currentNode.getLevel()])) {\r\n                            var resultRow = _.clone(currentIdentifiers);\r\n                            resultRow.data = currentNode.getData();\r\n\r\n                            result.push(resultRow);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // nothing to write back => continue!\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                this.getWriteBackDataRecursive(result, currentIdentifiers, currentNode.getChildren());\r\n            }\r\n        }\r\n\r\n        benchmark.endMeasurement('getWriteBackDataRecursive');\r\n    };\r\n\r\n    /**\r\n     * Corrects and enhances the writeBack-Information of all relevant KPIs\r\n     * @param {Object} meta\r\n     * @param {Object} dataMeta\r\n     */\r\n    this.updateWriteBackLevelInformation = function (meta, dataMeta) {\r\n        benchmark.startMeasurement('updateWriteBackLevelInformation');\r\n        var writeBackMeasures = meta.getWriteBackKPIs();\r\n\r\n        for (var measureIndex = 0; measureIndex < writeBackMeasures.length; measureIndex++) {\r\n            var measure = writeBackMeasures[measureIndex];\r\n\r\n            if (measure !== undefined) {\r\n                var levelsInformation = [];\r\n                for (var levelIndex = 0; levelIndex < measure.storageOptions.levels.length; levelIndex++) {\r\n                    var levelName = measure.storageOptions.levels[levelIndex];\r\n\r\n                    if(levelName === \"measures\") {\r\n                        levelName = dataMeta.measureDimensionName;\r\n                    }\r\n\r\n                    if (levelName in dataMeta.levelNameDimensionIndexMapping) {\r\n                        var levelInfo = {\r\n                            levelName: levelName,\r\n                            levelIndex: dataMeta.getLevelIndex(levelName),\r\n                            dimensionName: dataMeta.getDimensionName(levelName),\r\n                            dimensionIndex: dataMeta.getDimensionIndex(levelName)\r\n                        };\r\n\r\n                        levelsInformation.push(levelInfo);\r\n                    }\r\n                    else {\r\n                        log.error(\"The level with the name '\" + levelName + \"' cannot be found and will be ignored for the writeback!\");\r\n                    }\r\n                }\r\n\r\n                measure.storageOptions.levels = levelsInformation;\r\n            }\r\n        }\r\n\r\n        benchmark.endMeasurement('updateWriteBackLevelInformation');\r\n    }\r\n};\r\n\r\n/**\r\n *\r\n * @return {Object[]}\r\n */\r\nTree.prototype.getTimeDetails = function () {\r\n    return this.getDataMeta().timeDetails;\r\n};\r\n\r\n/**\r\n * Gets the number of all data columns (including the total column)\r\n * @return {number}\r\n */\r\nTree.prototype.getNumberOfDataColumns = function () {\r\n    return this.getDataMeta().noOfDataColumns;\r\n};\r\n\r\n/**\r\n * Collects all writeBackData of the tree via the measureDefinition of the KPIs\r\n * @memberOf Tree\r\n * @return {Object} Collection of all writeBack-Information\r\n */\r\nTree.prototype.getWriteBackData = function () {\r\n    benchmark.startMeasurement('getWriteBackData');\r\n    var meta = this.getMeta();\r\n    var dataMeta = this.getDataMeta();\r\n    var variables = this.getVariables();\r\n\r\n    for (var promotionId in variables.promotions) {\r\n        break;\r\n    }\r\n\r\n    this.updateWriteBackLevelInformation(meta, dataMeta);\r\n\r\n    var timeDimension = _.find(dataMeta.dimensions, {\"type\": \"time\"});\r\n    var startRecord = timeDimension.details[0];\r\n    var endRecord = timeDimension.details[timeDimension.details.length - 1];\r\n\r\n    // prepare the Result\r\n    var writeBackResult = {\r\n        id: promotionId,\r\n        startweek: startRecord.week,\r\n        endweek: endRecord.week,\r\n        startyear: startRecord.calendaryear,\r\n        endyear: endRecord.calendaryear,\r\n        firstdayofweek: timeDimension.firstdayofweek,\r\n        firstweekofyear: timeDimension.firstweekofyear,\r\n        data: []\r\n    };\r\n\r\n    // get all writeBack-Rows\r\n    var writeBackRows = [];\r\n    var currentRowIdentifiers = {};\r\n    var startNode = this.getRootNode();\r\n\r\n    this.getWriteBackDataRecursive(writeBackRows, currentRowIdentifiers, startNode.getChildren());\r\n    writeBackResult.data = writeBackRows;\r\n\r\n    benchmark.endMeasurement('getWriteBackData');\r\n    return writeBackResult;\r\n};\r\n\r\n/**\r\n * Gets all manual changes\r\n * returns {Object}\r\n */\r\nTree.prototype.getManualChanges = function () {\r\n    benchmark.startMeasurement(\"getManualChanges\");\r\n\r\n    var rootNode = this.getRootNode();\r\n    var meta = this.getMeta();\r\n    var initialIdentifiers = {};\r\n    initialIdentifiers[meta.axis.x] = undefined;\r\n    var internalChanges = rootNode.getManualChanges(initialIdentifiers);\r\n    var serializer = this.getManualChangesSerializer();\r\n\r\n    var manualChanges = serializer.serialize(internalChanges);\r\n\r\n    benchmark.endMeasurement(\"getManualChanges\");\r\n    return manualChanges;\r\n};\r\n\r\n/**\r\n * Creates a new instance of the Tree\r\n * @param data Data of the Tree\r\n * @param meta MetaData of the Tree\r\n * @param variables Additional Variables\r\n * @param {Object} manualChanges\r\n * @returns {Tree}\r\n */\r\nvar instantiate = function (data, meta, variables, manualChanges) {\r\n    var tree = new Tree();\r\n    tree.loadData(data, meta, variables, manualChanges);\r\n\r\n    return tree;\r\n};\r\n\r\nif (typeof module !== \"undefined\") {\r\n    module.exports.instantiate = instantiate;\r\n    module.exports.Tree = Tree;\r\n}\r\n\r\nfunction MyRawStream() {\r\n}\r\n\r\nMyRawStream.prototype.write = function (rec) {\r\n    console.log('[%s] %s: %s',\r\n        rec.time.toISOString(),\r\n        bunyan.nameFromLevel[rec.level],\r\n        rec.msg);\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// app/src/ui/calculationgrid/tree.js","\"use strict\";\r\nif (typeof require !== \"undefined\") {\r\n    var _ = require(\"lodash\");\r\n}\r\n\r\nvar measurements = [];\r\nvar enabled = false;\r\nvar lastParent = null;\r\n\r\n// Globals for output of measurements\r\nvar logDuration = 0.003;\r\nvar defaultDigits = 4;\r\n\r\nvar enable = function (state) {\r\n    enabled = state;\r\n};\r\n\r\nvar clearMeasurements = function () {\r\n    measurements = [];\r\n};\r\n\r\nvar startMeasurement = function (name) {\r\n    if (!enabled) {\r\n        return;\r\n    }\r\n\r\n    var existingMeasure = _.findIndex(measurements, function (measure) {\r\n        return measure.name === name;\r\n    });\r\n\r\n    if (existingMeasure < 0) {\r\n        var newMeasure = {\r\n            state: 0,\r\n            startTime: Date.now(),\r\n            firstStartTime: Date.now(),\r\n            overallDuration: -1,\r\n            occurrences: 0,\r\n            lastRecursionOccurrences: 0,\r\n            lowerLevelOccurrences: 0,\r\n            name: name,\r\n            recursionLevel: 1,\r\n            maxRecursion: 1,\r\n            parent: lastParent,\r\n            childOccurrences: 0,\r\n            minDuration: 9999999999,\r\n            maxDuration: 0\r\n        };\r\n\r\n        lastParent = newMeasure;\r\n\r\n        measurements.push(newMeasure);\r\n    }\r\n    else {\r\n        if (measurements[existingMeasure].recursionLevel > 0) {\r\n            measurements[existingMeasure].recursionLevel++;\r\n            measurements[existingMeasure].occurrences++;\r\n            measurements[existingMeasure].lastRecursionOccurrences++;\r\n            if (measurements[existingMeasure].recursionLevel > measurements[existingMeasure].maxRecursion) {\r\n                measurements[existingMeasure].maxRecursion = measurements[existingMeasure].recursionLevel;\r\n            }\r\n            if (measurements[existingMeasure].recursionLevel > 1) {\r\n                measurements[existingMeasure].lowerLevelOccurrences++;\r\n            }\r\n        }\r\n        else {\r\n            measurements[existingMeasure].startTime = Date.now();\r\n            measurements[existingMeasure].state = 0;\r\n            measurements[existingMeasure].recursionLevel = 1;\r\n            measurements[existingMeasure].parent = lastParent;\r\n            measurements[existingMeasure].lastRecursionOccurrences = 0;\r\n            lastParent = measurements[existingMeasure];\r\n        }\r\n    }\r\n};\r\n\r\nvar endMeasurement = function (name) {\r\n    if (!enabled) {\r\n        return;\r\n    }\r\n\r\n    var measureIdx = _.findIndex(measurements, function (measure) {\r\n        return measure.name === name;\r\n    });\r\n\r\n    if (measureIdx < 0) {\r\n        throw new Error('ERROR: Tried to stop a benchmark which does not exists: ' + name);\r\n    }\r\n\r\n    var measure = measurements[measureIdx];\r\n\r\n    measure.recursionLevel--;\r\n\r\n    if (measure.recursionLevel < 0) {\r\n        throw new Error('ERROR: Tried to close measurement with negative recursion level: ' + name);\r\n    }\r\n    else if (measure.recursionLevel === 0) {\r\n        var duration = Date.now() - measure.startTime;\r\n        measure.occurrences++;\r\n        measure.lastRecursionOccurrences++;\r\n        measure.overallDuration += duration;\r\n        measure.lastStopTime = Date.now();\r\n        measure.state = 1;\r\n        if (measure.parent) {\r\n            measure.parent.childOccurrences += measure.lastRecursionOccurrences;\r\n        }\r\n        lastParent = measure.parent;\r\n        measure.minDuration = _.min([measure.minDuration, duration]);\r\n        measure.maxDuration = _.max([measure.maxDuration, duration]);\r\n    }\r\n};\r\n\r\nvar printMeasurements = function (digits, all) {\r\n    if (!digits) {\r\n        digits = defaultDigits;\r\n    }\r\n\r\n    var printJSONArray = [];\r\n\r\n    measurements.forEach(function (element) {\r\n        var clearedDuration = round(element.overallDuration - (element.childOccurrences + element.lowerLevelOccurrences) * logDuration, digits);\r\n\r\n        if (all) {\r\n            printJSONArray.push({\r\n                name: element.name,\r\n                overallDuration: round(element.overallDuration, digits),\r\n                minDuration: element.minDuration,\r\n                maxDuration: element.maxDuration,\r\n                clearedDuration: clearedDuration,\r\n                averageDuration: round(element.overallDuration / element.occurrences, digits),\r\n                averageClearedDuration: round(clearedDuration / element.occurrences, digits),\r\n                measureLifeTime: element.lastStopTime - element.firstStartTime,\r\n                occurrences: element.occurrences,\r\n                maxRecursion: element.maxRecursion,\r\n                childOccurrences: element.childOccurrences\r\n            });\r\n        }\r\n        else {\r\n            printJSONArray.push({\r\n                name: element.name,\r\n                clearedDuration: clearedDuration,\r\n                averageClearedDuration: round(clearedDuration / element.occurrences, digits),\r\n                measureLifeTime: element.lastStopTime - element.firstStartTime,\r\n                occurrences: element.occurrences,\r\n                maxRecursion: element.maxRecursion\r\n            });\r\n        }\r\n    });\r\n\r\n    return JSON.stringify(printJSONArray);\r\n};\r\n\r\nfunction round(value, digits) {\r\n    return Math.round(value * Math.pow(10, digits)) / Math.pow(10, digits);\r\n}\r\n\r\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\r\n    module.exports.enable = enable;\r\n    module.exports.startMeasurement = startMeasurement;\r\n    module.exports.endMeasurement = endMeasurement;\r\n    module.exports.printMeasurements = printMeasurements;\r\n    module.exports.clearMeasurements = clearMeasurements;\r\n}\r\nelse {\r\n    window.enable = enable;\r\n    window.startMeasurement = startMeasurement;\r\n    window.endMeasurement = endMeasurement;\r\n    window.printMeasurements = printMeasurements;\r\n    window.clearMeasurements = clearMeasurements;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// app/src/ui/benchmark.js","\"use strict\";\r\n/* globals CasException */\r\n\r\nif (typeof require !== \"undefined\") {\r\n    var _ = require(\"lodash\");\r\n    var bunyan = require('bunyan');\r\n    var benchmark = require('../benchmark');\r\n    var reducers = require('./ArrayReducer').ArrayReducer;\r\n}\r\n\r\nvar logger = bunyan.createLogger({\r\n    name: \"CasAnalytics\",\r\n    streams: [{\r\n        level: 'info',\r\n        stream: new MyRawStream(),\r\n        type: 'raw'\r\n    }]\r\n});\r\n\r\n// CONSTANTS\r\nvar KEYWORD_AGGREGATION = \"aggregation\";\r\nvar KEYWORD_AGGREGATION_RULE = \"rule\";\r\nvar KEYWORD_AGGREGATION_SKIPPED_DIMENSIONS = \"skippeddimensions\";\r\nvar KEYWORD_AXIS = \"axis\";\r\nvar KEYWORD_DATASOURCE = \"datasource\";\r\nvar KEYWORD_DATASOURCE_TABLENAME = \"tablename\";\r\nvar KEYWORD_DATASOURCE_MEASURECODE = \"measurecode\";\r\nvar KEYWORD_DATASOURCE_WEEKOFFSET = \"weekoffset\";\r\nvar KEYWORD_DISPLAY = \"display\";\r\nvar KEYWORD_EDITABLE = \"editable\";\r\nvar KEYWORD_EDITABLE_CODE = \"code\";\r\nvar KEYWORD_EDITABLE_DISTRIBUTION = \"distribution\";\r\nvar KEYWORD_EDITABLE_ENABLEPASTWEEKS = \"enablepastweeks\";\r\nvar KEYWORD_EDITABLE_EDITMODE = \"editmode\";\r\nvar KEYWORD_FORMULA = \"formula\";\r\nvar KEYWORD_TYPE = \"type\";\r\nvar KEYWORD_TYPE_EDITABLE = \"editable\";\r\nvar KEYWORD_TYPE_CALCULATED = \"calculated\";\r\nvar KEYWORD_TYPE_READ = \"read\";\r\nvar KEYWORD_MEASURES = \"measures\";\r\nvar KEYWORD_NAME = \"name\";\r\nvar KEYWORD_STORAGEOPTIONS = \"storageoptions\";\r\nvar KEYWORD_STORAGEOPTIONS_CODE = \"code\";\r\nvar KEYWORD_STORAGEOPTIONS_STORAGELEVELS = \"storagelevels\";\r\nvar KEYWORD_STORAGEOPTIONS_WRITEBACK = \"writeback\";\r\nvar KEYWORD_TOTAL = \"total\";\r\nvar KEYWORD_TOTALCALCULATION = \"totalcalculation\";\r\nvar KEYWORD_TOTALCALCULATION_RULE = \"rule\";\r\n\r\n/**\r\n *\r\n * @typedef {Object} MeasureDefinitionCollection\r\n * @property {MeasureDefinition[]} measures\r\n * @property {Object} axis\r\n * @property {Object.<string, number|undefined>} measureIndexMapping\r\n * @property {Object.<string, number>} editableCodeIndexMapping\r\n * @property {Object.<string, number>} dimensionIndexMapping\r\n * @property {Object.<string, number>} levelIndexMapping\r\n * @property {number} _levelOfMeasures\r\n */\r\n\r\n/**\r\n * @typedef {{}} MeasureDefinition\r\n * @property {number} id\r\n * @property {string} name\r\n */\r\n\r\n/**\r\n *\r\n * @type {MeasureDefinitionCollection}\r\n */\r\nvar meta = {};\r\n\r\nvar log = logger.child({ widget_type: 'MetaParser' });\r\n\r\nvar parseMeta = function parseMeta(metaInformation) {\r\n\r\n    if (typeof metaInformation === \"string\") {\r\n        throw new CasException.CasException(\"Could not parse the KPI-Definitions. Use a JSON-Validator and correct all errors before retrying.\");\r\n    }\r\n\r\n    if (KEYWORD_AXIS in metaInformation) {\r\n        meta.axis = metaInformation[KEYWORD_AXIS];\r\n        computeDimensionIndexMapping(metaInformation[KEYWORD_AXIS].y);\r\n        computeLevelIndexMapping(metaInformation[KEYWORD_AXIS].y);\r\n    } else {\r\n        throw new CasException.CasException(\"Axis are missing\");\r\n    }\r\n\r\n    if (KEYWORD_MEASURES in metaInformation) {\r\n        computeMeasureDefinitions(metaInformation[KEYWORD_MEASURES]);\r\n    } else {\r\n        throw new CasException.CasException(\"Measures are missing!\");\r\n    }\r\n\r\n    addMetaFunctions();\r\n\r\n    return meta;\r\n};\r\n\r\nvar addMetaFunctions = function () {\r\n    meta.getLevelOfMeasures = getLevelOfMeasures;\r\n    meta.getMeasureIndex = getMeasureIndex;\r\n    meta.getLevelIndex = getLevelIndex;\r\n    meta.getDimensionIndex = getDimensionIndex;\r\n    meta.getDataSourceBasedKPIs = getDataSourceBasedKPIs;\r\n    meta.getWriteBackKPIs = getWriteBackKPIs;\r\n};\r\n\r\n/**\r\n * Gets the information which grouping level the \"measures\"-level is\r\n * @function\r\n * @returns {number}\r\n */\r\nvar getLevelOfMeasures = function () {\r\n    return meta._levelOfMeasures;\r\n};\r\n\r\nfunction parseSkippedDimensions(measureDefinition, aggregationInformation) {\r\n\r\n    measureDefinition.hasSkippedDimensions = false;\r\n    measureDefinition.skippedDimensions = [];\r\n    measureDefinition.isDimensionSkipped = function (dimensionId) {\r\n        return (measureDefinition.skippedDimensions[dimensionId] !== undefined);\r\n    };\r\n\r\n    if (KEYWORD_AGGREGATION_SKIPPED_DIMENSIONS in aggregationInformation) {\r\n        var skippedDimensions = aggregationInformation[KEYWORD_AGGREGATION_SKIPPED_DIMENSIONS];\r\n\r\n        // Validate the Dimensions (Throws an error if a Dimension is not specified)\r\n        for (var i = 0; i < skippedDimensions.length; i++) {\r\n            var skippedDimensionName = skippedDimensions[i];\r\n            measureDefinition.skippedDimensions[getDimensionIndex(skippedDimensionName)] = true;\r\n\r\n            measureDefinition.hasSkippedDimensions = true;\r\n        }\r\n    } else {\r\n        log.debug(\"No skipped Dimensions specified\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Parses all KPI-Type related information of the measure\r\n * @param measureDefinition\r\n * @param {Object} measure\r\n * @param {string} measure.type\r\n * @param {string} measure.formula\r\n * @param {Object} measure.datasource\r\n * @param {Object} measure.editable\r\n */\r\nfunction parseKPITypeInstruction(measureDefinition, measure) {\r\n\r\n    measureDefinition.computed = false;\r\n    measureDefinition.isDataSourceBased = false;\r\n    measureDefinition.isEditable = false;\r\n\r\n    if (KEYWORD_TYPE in measure) {\r\n        var KPIType = measure[KEYWORD_TYPE];\r\n\r\n        switch (KPIType) {\r\n            case KEYWORD_TYPE_CALCULATED:\r\n                parseKpiAsFormula(measureDefinition, measure);\r\n                break;\r\n            case KEYWORD_TYPE_READ:\r\n                parseKpiAsDataSource(measureDefinition, measure);\r\n                break;\r\n            case KEYWORD_TYPE_EDITABLE:\r\n                parseKpiAsEditable(measureDefinition, measure);\r\n                break;\r\n            default:\r\n                log.warn(\"Unknown KPITYPE. Implementation incomplete\");\r\n                throw new CasException.CasException(\"Error while parsing the KPI '\" + measureDefinition.name + \"'. Unknown KpiType '\" + KPIType + \"'\");\r\n        }\r\n    } else {\r\n        throw new CasException.CasException(\"Error while parsing the KPI '\" + measureDefinition.name + \"'. \" + KEYWORD_TYPE + \" not specified\");\r\n    }\r\n}\r\n\r\n/**\r\n * Parses a KPI as a TableBased KPI (Baseline, Shipment,...)\r\n * @param measureDefinition\r\n * @param {Object} measure\r\n * @param {Object} measure.datasource\r\n * @param {string} measure.datasource.tablename\r\n * @param {string} measure.datasource.measurecode\r\n * @param {number} measure.datasource.weekoffset\r\n * @throws {CasException}\r\n */\r\nfunction parseKpiAsDataSource(measureDefinition, measure) {\r\n    measureDefinition.isDataSourceBased = true;\r\n    measureDefinition.dataSource = {\r\n        tableName: \"\",\r\n        measureCode: \"\",\r\n        weekOffset: 0\r\n    };\r\n\r\n    if (KEYWORD_DATASOURCE in measure) {\r\n        var dataSource = measure[KEYWORD_DATASOURCE];\r\n\r\n        if (KEYWORD_DATASOURCE_TABLENAME in dataSource) {\r\n            measureDefinition.dataSource.tableName = dataSource[KEYWORD_DATASOURCE_TABLENAME];\r\n        } else {\r\n            log.error(\"The TableName for the KPI \" + measureDefinition.name + \" is missing!\");\r\n        }\r\n\r\n        if (KEYWORD_DATASOURCE_MEASURECODE in dataSource) {\r\n            measureDefinition.dataSource.measureCode = dataSource[KEYWORD_DATASOURCE_MEASURECODE];\r\n        } else {\r\n            log.error(\"The MeasureCode for the KPI \" + measureDefinition.name + \" is missing!\");\r\n        }\r\n\r\n        if (KEYWORD_DATASOURCE_WEEKOFFSET in dataSource) {\r\n            measureDefinition.dataSource.weekOffset = dataSource[KEYWORD_DATASOURCE_WEEKOFFSET];\r\n        } else {\r\n            log.warn(\"The WeekOffset for the KPI \" + measureDefinition.name + \" is missing!\");\r\n        }\r\n\r\n    } else {\r\n        throw new CasException.CasException(\"The Data-Source-Information for the KPI \" + measureDefinition.name + \" is missing!\");\r\n    }\r\n}\r\n\r\n/**\r\n * Parses a KPI as a formula based one\r\n * @param measureDefinition\r\n * @param {Object} measure\r\n * @param {string} measure.formula\r\n */\r\nfunction parseKpiAsFormula(measureDefinition, measure) {\r\n    measureDefinition.computed = true;\r\n\r\n    if (!(KEYWORD_FORMULA in measure)) {\r\n        log.error(measureDefinition.name + \": Specified a computed measure but no formula! Using fallback (null-Value).\");\r\n        measure.formula = \"() => null\";\r\n    }\r\n\r\n    try {\r\n        var formula = parseFormula(measure[KEYWORD_FORMULA]);\r\n        measureDefinition.func = formula.func;\r\n        measureDefinition.args = formula.args;\r\n    } catch (e) {\r\n        throw new CasException.CasException(\"Error while parsing the formula for KPI: '\" + measureDefinition.name + \"'.\", e);\r\n    }\r\n}\r\n\r\n/**\r\n * Parses the information of editable KPIs\r\n * @param measureDefinition\r\n * @param {Object} measure\r\n * @param {Object} measure.editable\r\n * @param {string} measure.editable.distribution\r\n */\r\nfunction parseKpiAsEditable(measureDefinition, measure) {\r\n    measureDefinition.isEditable = true;\r\n    measureDefinition.distributionInformation = {\r\n        code: \"\",\r\n        enablePastWeeks: false,\r\n        measureName: \"\",\r\n        measureIndex: -1,\r\n        mode: \"week\"\r\n    };\r\n\r\n    if (KEYWORD_EDITABLE in measure) {\r\n        var editableInformation = measure[KEYWORD_EDITABLE];\r\n    \r\n        if (KEYWORD_EDITABLE_CODE in editableInformation) {\r\n            var editCode = editableInformation[KEYWORD_EDITABLE_CODE];\r\n        \r\n            measureDefinition.distributionInformation.code = editCode;\r\n            meta.editableCodeIndexMapping[editCode] = measureDefinition.id;\r\n        } else {\r\n            throw new CasException.CasException(\"The measure on index \" + measureDefinition.id + \" with the name \" + measureDefinition.name + \" is defined as editable but has no code assigned!\");\r\n        }\r\n    \r\n        if(KEYWORD_EDITABLE_EDITMODE in editableInformation) {\r\n            var mode = editableInformation[KEYWORD_EDITABLE_EDITMODE];\r\n            if(mode === \"total\") {\r\n                measureDefinition.distributionInformation.mode = \"total\";\r\n            } else if(mode === \"week\") {\r\n                measureDefinition.distributionInformation.mode = \"week\";\r\n            } else {\r\n                measureDefinition.distributionInformation.mode = \"week\";\r\n                log.warn(\"The measure on index \" + measureDefinition.id + \" with the name \" + measureDefinition.name + \" has an unknown or missing editmode '\" + mode + \"'!. Using fallback 'week'\");\r\n            }\r\n        }\r\n    \r\n        if(measureDefinition.distributionInformation.mode === \"week\") {\r\n            if (KEYWORD_EDITABLE_ENABLEPASTWEEKS in editableInformation) {\r\n                measureDefinition.distributionInformation.enablePastWeeks = (editableInformation[KEYWORD_EDITABLE_ENABLEPASTWEEKS] === true);\r\n            }\r\n        \r\n            if (KEYWORD_EDITABLE_DISTRIBUTION in editableInformation) {\r\n                var referencedMeasureName = editableInformation[KEYWORD_EDITABLE_DISTRIBUTION];\r\n            \r\n                measureDefinition.distributionInformation.measureName = referencedMeasureName;\r\n                measureDefinition.distributionInformation.measureIndex = getMeasureIndex(referencedMeasureName);\r\n            } else {\r\n                throw new CasException.CasException(\"The KPI \" + measureDefinition.name + \" is specified as editable but the distribution information is missing.\");\r\n            }\r\n        }\r\n    } else {\r\n        throw new CasException.CasException(\"The KPI \" + measureDefinition.name + \" is specified as editable but the information is incomplete.\");\r\n    }\r\n}\r\n\r\n/**\r\n * Parses all information for the aggregation\r\n * @param measureDefinition\r\n * @param {Object} measure\r\n * @param {Object} measure.aggregation\r\n * @param {string} measure.aggregation.rule\r\n * @param {string[]} measure.aggregation.skippeddimensions\r\n */\r\nfunction parseAggregationInstruction(measureDefinition, measure) {\r\n    measureDefinition.aggregation = reducers.none;\r\n    measureDefinition.aggregationIsFormulaBased = false;\r\n\r\n    if (KEYWORD_AGGREGATION in measure) {\r\n        var aggregationInformation = measure[KEYWORD_AGGREGATION];\r\n\r\n        if (aggregationInformation[KEYWORD_AGGREGATION_RULE] !== undefined) {\r\n            if (aggregationInformation[KEYWORD_AGGREGATION_RULE] === \"formula\") {\r\n                measureDefinition.aggregationIsFormulaBased = true;\r\n            } else if (aggregationInformation[KEYWORD_AGGREGATION_RULE] in reducers) {\r\n                measureDefinition.aggregation = reducers[aggregationInformation[KEYWORD_AGGREGATION_RULE]];\r\n            } else {\r\n                log.warn(\"The Aggregation rule of the KPI \" + measureDefinition.name + \" is not available\");\r\n            }\r\n        } else {\r\n            log.warn(\"The KPI \" + measureDefinition.name + \" has no Aggregation rule specified.\");\r\n        }\r\n\r\n        parseSkippedDimensions(measureDefinition, aggregationInformation);\r\n\r\n    } else {\r\n        log.warn(\"The KPI \" + measureDefinition.name + \" has no Aggregation information specified.\");\r\n    }\r\n}\r\n\r\n/**\r\n * Parses all information for the calculation of the total\r\n * @param measureDefinition\r\n * @param {Object} measure\r\n * @param {Object} measure.totalcalculation\r\n * @param {string} measure.totalcalculation.rule\r\n */\r\nfunction parseTotalCalculationInstruction(measureDefinition, measure) {\r\n    measureDefinition.totalCalculation = reducers.none;\r\n    measureDefinition.totalCalculationIsFormulaBased = false;\r\n\r\n    if (KEYWORD_TOTALCALCULATION in measure) {\r\n        var totalCalculationInformation = measure[KEYWORD_TOTALCALCULATION];\r\n\r\n        if (totalCalculationInformation[KEYWORD_TOTALCALCULATION_RULE] !== undefined) {\r\n            if (totalCalculationInformation[KEYWORD_TOTALCALCULATION_RULE] === \"formula\") {\r\n                measureDefinition.totalCalculationIsFormulaBased = true;\r\n            } else if (totalCalculationInformation[KEYWORD_TOTALCALCULATION_RULE] in reducers) {\r\n                measureDefinition.totalCalculation = reducers[totalCalculationInformation[KEYWORD_TOTALCALCULATION_RULE]];\r\n            } else {\r\n                log.warn(\"The TotalCalculation rule of the KPI \" + measureDefinition.name + \" is not available\");\r\n            }\r\n        } else {\r\n            log.warn(\"The KPI \" + measureDefinition.name + \" has no TotalCalculation rule specified.\");\r\n        }\r\n    } else {\r\n        log.warn(\"The KPI \" + measureDefinition.name + \" has no TotalCalculation information specified.\");\r\n    }\r\n}\r\n\r\n/**\r\n * Parses all information for the displaying\r\n * @param measureDefinition\r\n * @param {Object} measure\r\n * @param {Object} measure.display\r\n * @param {boolean} [measure.display.enabled = true]\r\n * @param {number} [measure.display.round = 2]\r\n */\r\nfunction parseDisplayInstruction(measureDefinition, measure) {\r\n    var displayInformation = {\r\n        enabled: true,\r\n        round: 2\r\n    };\r\n\r\n    if (KEYWORD_DISPLAY in measure) {\r\n        var display = measure[KEYWORD_DISPLAY];\r\n\r\n        if (display.enabled !== undefined) {\r\n            displayInformation.enabled = display.enabled;\r\n        }\r\n\r\n        if (display.round !== undefined) {\r\n            displayInformation.round = display.round;\r\n        }\r\n    } else {\r\n\r\n        log.info(\"The measure \" + measureDefinition.name + \"on index \" + measureDefinition.id + \" has no display property defined. Using fallback.\");\r\n    }\r\n\r\n    measureDefinition.display = displayInformation;\r\n}\r\n\r\n/**\r\n *\r\n * @param measureDefinition\r\n * @param measure\r\n */\r\nfunction parseStorageInstructions(measureDefinition, measure) {\r\n    measureDefinition.storageOptions = {\r\n        code: \"\",\r\n        writeBack: false,\r\n        levels: []\r\n    };\r\n\r\n    if (KEYWORD_STORAGEOPTIONS in measure) {\r\n        var storageOptions = measure[KEYWORD_STORAGEOPTIONS];\r\n\r\n        measureDefinition.storageOptions.writeBack = (storageOptions[KEYWORD_STORAGEOPTIONS_WRITEBACK] === true);\r\n\r\n        if (measureDefinition.storageOptions.writeBack) {\r\n\r\n            if (KEYWORD_STORAGEOPTIONS_CODE in storageOptions) {\r\n                measureDefinition.storageOptions.code = storageOptions[KEYWORD_STORAGEOPTIONS_CODE];\r\n            } else {\r\n                throw new CasException.CasException(\"The measure on index \" + measureDefinition.id + \" with the name \" + measureDefinition.name + \" is defined as writeBack but has no code assigned!\");\r\n            }\r\n\r\n            if (KEYWORD_STORAGEOPTIONS_STORAGELEVELS in storageOptions) {\r\n                var levels = storageOptions[KEYWORD_STORAGEOPTIONS_STORAGELEVELS];\r\n                if (_.isArray(levels)) {\r\n                    levels.forEach(function (levelName) {\r\n                        measureDefinition.storageOptions.levels.push(levelName);\r\n                    });\r\n                } else {\r\n                    log.error(\"The measure \" + measureDefinition.name + \"on index \" + measureDefinition.id + \" has malformed storageOptions-Information.\");\r\n                }\r\n                measureDefinition.storageOptions.levels = storageOptions[KEYWORD_STORAGEOPTIONS_STORAGELEVELS];\r\n            }\r\n\r\n            if (measureDefinition.storageOptions.levels.length === 0) {\r\n                measureDefinition.storageOptions.writeBack = false;\r\n                log.warn(measureDefinition.name + \": Writeback activated but no StorageLevel defined. Deactivating writeback for this measure temporary.\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Parses the name of the measure\r\n * @param measureDefinition\r\n * @param {Object} measure\r\n * @param {string} measure.name\r\n */\r\nfunction parseMeasureName(measureDefinition, measure) {\r\n    if (KEYWORD_NAME in measure) {\r\n        measureDefinition.name = measure[KEYWORD_NAME];\r\n    } else {\r\n        measureDefinition.name = \"Undefined\";\r\n        throw new CasException.CasException(\"The measure on index \" + measureDefinition.id + \" has no name assigned!\");\r\n    }\r\n}\r\n\r\nfunction computeMeasureDefinitions(measures) {\r\n    meta.measures = [];\r\n    meta.editableCodeIndexMapping = {};\r\n    computeMeasureIndexMapping(measures);\r\n\r\n    for (var i = 0; i < measures.length; i++) {\r\n        var measure = measures[i];\r\n        var measureDefinition = {};\r\n\r\n        measureDefinition.id = i;\r\n\r\n        parseMeasureName(measureDefinition, measure);\r\n\r\n        parseDisplayInstruction(measureDefinition, measure);\r\n\r\n        parseAggregationInstruction(measureDefinition, measure);\r\n\r\n        parseTotalCalculationInstruction(measureDefinition, measure);\r\n\r\n        parseKPITypeInstruction(measureDefinition, measure);\r\n\r\n        parseStorageInstructions(measureDefinition, measure);\r\n\r\n        meta.measures[i] = measureDefinition;\r\n\r\n        measureDefinition.dependingMeasures = [];\r\n\r\n        /**\r\n         * Registers a measureDefinition as a dependent measure.\r\n         * @param dependingMeasure\r\n         */\r\n        var addDependency = function (dependingMeasure) {\r\n            if (this.id === dependingMeasure.id) {\r\n                throw new CasException.CasException(\"The KPI '\" + dependingMeasure.name + \"' cannot depend on itself!\");\r\n            } else if (this.dependingMeasures[dependingMeasure.id] === undefined) {\r\n                this.dependingMeasures[dependingMeasure.id] = dependingMeasure;\r\n            } else {\r\n                log.debug(\"KPI '\" + dependingMeasure.name + \"' already added as a dependency\");\r\n            }\r\n        };\r\n\r\n        measureDefinition.registerDependency = addDependency;\r\n\r\n        /**\r\n         * indicates whether the aggregation uses a formula or not\r\n         */\r\n        measureDefinition.isAggregationBasedOnFormula = function () {\r\n            return this.aggregationIsFormulaBased;\r\n        };\r\n\r\n        /**\r\n         * indicates whether the total calculation uses a formula or not\r\n         */\r\n        measureDefinition.isTotalCalculationBasedOnFormula = function () {\r\n            return this.totalCalculationIsFormulaBased;\r\n        };\r\n    }\r\n\r\n    computeMeasureDependencies(meta.measures);\r\n}\r\n\r\n/**\r\n * Computes all direct dependencies between two KPIs\r\n * @param {Object[]} measureDefinitions\r\n */\r\nfunction computeMeasureDependencies(measureDefinitions) {\r\n\r\n    for (var i = 0; i < measureDefinitions.length; i++) {\r\n        var measureDefinition = measureDefinitions[i];\r\n\r\n        // only necessary for computed KPIs\r\n        if (measureDefinition.computed) {\r\n            for (var argIndex = 0; argIndex < measureDefinition.args.length; argIndex++) {\r\n                var functionArgument = measureDefinition.args[argIndex];\r\n                measureDefinitions[functionArgument.measureIndex].registerDependency(measureDefinition);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction computeMeasureIndexMapping(measures) {\r\n    meta.measureIndexMapping = {};\r\n    for (var i = 0; i < measures.length; i++) {\r\n        var measure = measures[i];\r\n\r\n        if (meta.measureIndexMapping[measure.name] === undefined) {\r\n            meta.measureIndexMapping[measure.name] = i;\r\n        } else {\r\n            throw new CasException.CasException(\"KPI-Names must be unique, but found the KPI '\" + measure.name + \"' multiple times.\");\r\n        }\r\n    }\r\n}\r\n\r\nfunction computeDimensionIndexMapping(dimensions) {\r\n    meta.dimensionIndexMapping = {};\r\n    for (var i = 0; i < dimensions.length; i++) {\r\n        var dimensionName = dimensions[i];\r\n        meta.dimensionIndexMapping[dimensionName] = i;\r\n\r\n        if (dimensionName === KEYWORD_MEASURES) {\r\n            meta._levelOfMeasures = i;\r\n        }\r\n    }\r\n}\r\n\r\nfunction getDimensionIndex(dimensionName) {\r\n    if (dimensionName in meta.dimensionIndexMapping) {\r\n        return meta.dimensionIndexMapping[dimensionName];\r\n    } else {\r\n        throw new CasException.CasException(\"Could not find the dimension with the name: \" + dimensionName);\r\n    }\r\n}\r\n\r\nvar computeLevelIndexMapping = function (levels) {\r\n    meta.levelIndexMapping = {};\r\n    for (var i = 0; i < levels.length; i++) {\r\n        var levelName = levels[i];\r\n        meta.levelIndexMapping[levelName] = i;\r\n\r\n        if (levelName === KEYWORD_MEASURES) {\r\n            meta._levelOfMeasures = i;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the index of a specific level via its name\r\n * @throws {CasException} Throws an exception if the levelName does not exist.\r\n * @todo Check if this is helpful after changing to dimensions!\r\n * @param levelName\r\n */\r\nfunction getLevelIndex(levelName) {\r\n    if (levelName in meta.levelIndexMapping) {\r\n        return meta.levelIndexMapping[levelName];\r\n    } else {\r\n        throw new CasException.CasException(\"Could not find the level with the name: \" + levelName);\r\n    }\r\n}\r\n\r\n/**\r\n * Parses all function arguments\r\n * @param {string} argumentString\r\n * @return {Object}\r\n */\r\nfunction parseFunctionArguments(argumentString) {\r\n    var functionArguments = [];\r\n\r\n    if (argumentString.trim() !== \"\") {\r\n        var argumentStrings = argumentString.split(/,/g);\r\n        for (var i = 0; i < argumentStrings.length; i++) {\r\n            var functionArgument = { \"isComplexArgument\": false };\r\n            var argumentInformation = argumentStrings[i].split(/\\$/g);\r\n\r\n            if (argumentInformation.length > 3) {\r\n                throw new CasException.CasException(\"Invalid number of function-argument-delimiter. There are no more than 2 delimiters allowed, but found \" + (argumentInformation.length - 1) + \" delimiters.\");\r\n            } else {\r\n                functionArgument.measureName = argumentInformation[0].trim();\r\n                functionArgument.measureIndex = getMeasureIndex(functionArgument.measureName);\r\n\r\n                if (argumentInformation.length > 1) {\r\n                    functionArgument.isComplexArgument = true;\r\n                    functionArgument.levelName = argumentInformation[1].trim();\r\n                    //FixMe: This cannot be solved without the Data/Hierarchy-Information!\r\n                    functionArgument.levelIndex = getLevelIndex(functionArgument.levelName);\r\n                } else {\r\n                    functionArgument.levelName = undefined;\r\n                    functionArgument.levelIndex = undefined;\r\n                }\r\n\r\n                if (argumentInformation.length > 2) {\r\n                    argumentInformation[2] = argumentInformation[2].trim().toLowerCase();\r\n                    functionArgument.useTotal = (argumentInformation[2] === KEYWORD_TOTAL);\r\n                } else {\r\n                    functionArgument.useTotal = false;\r\n                }\r\n            }\r\n\r\n            functionArguments.push(functionArgument);\r\n        }\r\n    }\r\n\r\n    return functionArguments;\r\n}\r\n\r\nfunction parseFormula(formulaString) {\r\n    var parsingResult = {};\r\n\r\n    var formulaParts = formulaString.split(\"=>\");\r\n    var args = formulaParts[0];\r\n    var body = formulaParts[1];\r\n\r\n    // replace opening and closing parenthesis\r\n    args = args.replace(/[\\(\\)]/g, \"\").trim();\r\n\r\n    // Create function with args as parameters (if exists) and VARS as additional Parameter\r\n    parsingResult.func = new Function(\"calcHelper\" + (args.length > 0 ? \", \" + args : \"\"),\r\n        // Add the Body of the function\r\n        (body.indexOf(\"{\") < 0 ? \"return \" : \"\") + body);\r\n\r\n    // Split the Function Arguments by \",\" and whitespaces if any exist\r\n    parsingResult.args = parseFunctionArguments(args);\r\n\r\n    return parsingResult;\r\n}\r\n\r\n/**\r\n * Gets the index of a measure based on its name.\r\n * @param measuresName\r\n * @returns {number} the index of the measure (0...n)\r\n * @throws {Error} Throws an error if the measureName is not valid/cannot be found.\r\n */\r\nfunction getMeasureIndex(measuresName) {\r\n    if (measuresName in meta.measureIndexMapping) {\r\n        return meta.measureIndexMapping[measuresName];\r\n    } else {\r\n        throw new CasException.CasException(\"Could not find the measure with the name: \" + measuresName);\r\n    }\r\n}\r\n\r\n/**\r\n * Gets all MeasureDefinitions which are based on database tables\r\n * @return {Array}\r\n */\r\nfunction getDataSourceBasedKPIs() {\r\n    return _.filter(meta.measures, function (measureDefinition) {\r\n        return measureDefinition.isDataSourceBased;\r\n    });\r\n}\r\n\r\n/**\r\n * Gets all MeasureDefinitions where writeBack is enabled\r\n * @return {Object[]}\r\n */\r\nfunction getWriteBackKPIs() {\r\n    return _.filter(meta.measures, function (measureDefinition) {\r\n        return measureDefinition.storageOptions.writeBack;\r\n    });\r\n}\r\n\r\nif (typeof module !== \"undefined\") {\r\n    module.exports.parseMeta = parseMeta;\r\n}\r\n\r\nfunction MyRawStream() {\r\n\r\n}\r\n\r\nMyRawStream.prototype.write = function (rec) {\r\n    console.log('[%s] %s: %s',\r\n        rec.time.toISOString(),\r\n        bunyan.nameFromLevel[rec.level],\r\n        rec.msg);\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// app/src/ui/calculationgrid/MetaParser.js","/**\r\n * Created by carl.r.rieger on 08-Jul-16.\r\n */\r\n\r\n/**\r\n * Calculates the sum of all values in the array\r\n * @param {number} previousValue\r\n * @param {number} currentValue\r\n * @return {number}\r\n */\r\nfunction sum(previousValue, currentValue) {\r\n    if (previousValue === null || previousValue === undefined || isNaN(previousValue)) {\r\n        return currentValue;\r\n    }\r\n    else if (currentValue === null || currentValue === undefined || isNaN(currentValue)) {\r\n        return previousValue;\r\n    }\r\n    else {\r\n        return previousValue + currentValue;\r\n    }\r\n}\r\n\r\n/**\r\n * Calculates the minimum of all values in the array\r\n * @param {number} previousValue\r\n * @param {number} currentValue\r\n * @return {number}\r\n */\r\nfunction min(previousValue, currentValue) {\r\n    if (previousValue === null || previousValue === undefined || isNaN(previousValue)) {\r\n        return currentValue;\r\n    }\r\n    else if (currentValue === null || currentValue === undefined || isNaN(currentValue)) {\r\n        return previousValue;\r\n    }\r\n    else {\r\n        return Math.min(previousValue, currentValue);\r\n    }\r\n}\r\n\r\n/**\r\n * Calculates the maximum of all values in the array\r\n * @param {number} previousValue\r\n * @param {number} currentValue\r\n * @return {number}\r\n */\r\nfunction max(previousValue, currentValue) {\r\n    if (previousValue === null || previousValue === undefined || isNaN(previousValue)) {\r\n        return currentValue;\r\n    }\r\n    else if (currentValue === null || currentValue === undefined || isNaN(currentValue)) {\r\n        return previousValue;\r\n    }\r\n    else {\r\n        return Math.max(previousValue, currentValue);\r\n    }\r\n}\r\n\r\n/**\r\n * Calculates the average of all values in the array excluding null values\r\n * @param {number} previousValue\r\n * @param {number} currentValue\r\n * @param {number} currentIndex\r\n * @param {number[]} array\r\n * @return {number}\r\n */\r\nfunction average(previousValue, currentValue, currentIndex, array) {\r\n    var returnValue;\r\n\r\n    // set the values to 0 if they are null, undefined or NaN\r\n    previousValue = previousValue || 0;\r\n    currentValue = currentValue || 0;\r\n\r\n    returnValue = previousValue + currentValue;\r\n\r\n    // at the and of the reduce-function count the number of notNullValues to calculate the average\r\n    if (currentIndex === array.length - 1) {\r\n        var countIsNotNull = 0;\r\n        for (var i = 0; i < array.length; i++) {\r\n            if (array[i] !== null && array[i] !== undefined && !isNaN(array[i])) {\r\n                countIsNotNull++;\r\n            }\r\n        }\r\n\r\n        if (countIsNotNull > 0) {\r\n            returnValue = returnValue / countIsNotNull;\r\n        }\r\n        else {\r\n            returnValue = null;\r\n        }\r\n    }\r\n\r\n    return returnValue;\r\n}\r\n\r\n/**\r\n * Returns null as aggregated value\r\n * @return {null}\r\n */\r\nfunction none() {\r\n    return null;\r\n}\r\n\r\nvar reducers = {\r\n    \"sum\": sum,\r\n    \"min\": min,\r\n    \"max\": max,\r\n    \"avg\": average,\r\n    \"null\": none,\r\n    \"none\": none\r\n};\r\n\r\nmodule.exports.ArrayReducer = reducers;\r\n\n\n\n// WEBPACK FOOTER //\n// app/src/ui/calculationgrid/ArrayReducer.js","\"use strict\";\r\nvar _ = require(\"lodash\");\r\n\r\nDate.prototype.ACSF_dayDiff = function (date) {\r\n    var timestamp = this.getTime();\r\n    var dateTimestamp = date.getTime();\r\n    return (timestamp - dateTimestamp) / 86400000;  // milliseconds per day\r\n};\r\n\r\n/**\r\n * Provides helper methods for a calculation formula\r\n * @param {Object} meta Information about the resulting structure (ColumnOrder, CalculationFormulas,...)\r\n * @param {Object} meta.axis Information about the axis of the grid\r\n * @param {string} meta.axis.x Reference to the columns in data.columns\r\n * @param {string[]} meta.axis.y Reference to the columns in data.columns. Must include \"measures\" as KeyWord\r\n * @param {Object[]} meta.measures Collection of all measures of the grid\r\n * @param {string} meta.measures[].name Name of the measures (for displaying and as reference to columns if provided in data.data)\r\n * @param {boolean} meta.measures[].display Indicates if the measure shall be displayed or is only necessary for calculation\r\n * @param {boolean} meta.measures[].editable Indicates if this measure can be edited\r\n * @param {boolean} meta.measures[].writeBack Indicates if the edited values of this measure shall be persisted (only in use with editable=true)\r\n * @param {boolean} meta.measures[].computed Indicates if this measure must be calculated\r\n * @param {string} meta.measures[].formula Formula used for the calculation of this measure (only in use with computed=true), must be a valid JS-Function. Can reference measures and VARS\r\n * @param {string} meta.measures[].aggregation Instruction how to aggregate this measure (null|+|min|max...)\r\n * @param {string} meta.measures[].totalColumnCalc Instruction how to aggregate the TotalColumn (null|+|min|max...) (see meta.total.display)\r\n * @param {Object} meta.total Information if the TotalColumn should be calculated/displayed\r\n * @param {boolean} meta.total.display Indicates if the TotalColumn shall be calculated and displayed (see data.columns[].totalColumnCalc)\r\n * @param {string} meta.total.label Label to be displayed/returned for the TotalColumn\r\n * @param {Object} metaData The data itself and information about the structure of the Data\r\n * @param {number[][]} metaData.data The Data itself and the MetaData about the given Data\r\n * @param {Object[]} metaData.dimensions Collection of all columns information of the tableData\r\n * @param {String} metaData.dimensions[].name Name of the Column\r\n * @param {String[]} metaData.dimensions[].lookups 0-Indexed lookUp-Values for the tableData\r\n * @param {Object} variables promotion variables of the current promotion\r\n * @param {Object} logger object\r\n */\r\nvar CalcHelper = function CalcHelper(meta, metaData, variables, logger) {\r\n    /**\r\n     * Current TreeNode\r\n     * @type {TreeNode}\r\n     * @private\r\n     */\r\n    var _node = null;\r\n\r\n    /**\r\n     * Currently calculated Week\r\n     * @type number|null\r\n     * @private\r\n     */\r\n    var _weekIndex = null;\r\n\r\n    /**\r\n     * Current position within the Tree\r\n     * @type {number[]|null}\r\n     * @private\r\n     */\r\n    var _position = null;\r\n\r\n    var _contextVariables = {};\r\n\r\n    var self = this;\r\n    var _externalLogger = logger.child({widget_type: \"formula\"});  // logger for formulas\r\n    var _internalLogger = logger.child({widget_type: 'calcHelper'});\r\n    var _weekVariables = _.find(metaData.dimensions, function (dim) {\r\n        return dim.type === \"time\";\r\n    });\r\n\r\n    /**\r\n     * sets the node into the context\r\n     * @param {TreeNode} node The node that defines the new context\r\n     */\r\n    this.setNode = function (node) {\r\n        _node = node;\r\n        _position = null;\r\n        _weekIndex = null;\r\n        _contextVariables = {};\r\n    };\r\n\r\n    this.setWeekIndex = function (weekIndex) {\r\n        _weekIndex = weekIndex;\r\n    };\r\n\r\n    /**\r\n     * Gets the position of the current node in the tree (path)\r\n     * @return {number[]}\r\n     */\r\n    this.getPosition = function () {\r\n        if (_position === null) {\r\n            _position = _node.getPositionInTree();\r\n        }\r\n        return _position;\r\n    };\r\n\r\n    /**\r\n     * Returns the level of the current node as text\r\n     * return {string|null}\r\n     */\r\n    this.getLevelName = function () {\r\n        if (_node === null) {\r\n            _internalLogger.fatal(this.formatLogMessage('getLevelName: No node defined.'));\r\n            return null;\r\n        }\r\n        // todo: hierarchy levels\r\n        var level = _node.getDimensionId();\r\n\r\n        return meta.axis.y[level];\r\n    };\r\n\r\n    /**\r\n     * Gets a set of variables based on the current context and the defined dimension\r\n     * @param {String} dimensionName\r\n     * @returns {null|Object}\r\n     */\r\n    var getContextVariables = function(dimensionName) {\r\n        if(_contextVariables[dimensionName] !== undefined) {\r\n            // get cached variables\r\n            return _contextVariables[dimensionName];\r\n        } else {\r\n            var levelVariables;\r\n            var id;\r\n\r\n            if (dimensionName === \"Promotion\") {\r\n                levelVariables = variables[\"promotions\"];\r\n                for (id in levelVariables) {\r\n                    break;\r\n                }  // get the 'first' promotion id\r\n            }\r\n            else {\r\n                var dimension = metaData.getDimensionByName(dimensionName);\r\n                var levelIdx = metaData.getLevelIndex(dimensionName);\r\n                var lookupIndex = self.getPosition()[levelIdx];\r\n                id = dimension.lookups[lookupIndex];\r\n                var levelNamePlural = dimensionName.toLowerCase() + 's';\r\n\r\n                levelVariables = variables[levelNamePlural];\r\n                if (levelVariables === undefined) {\r\n                    _internalLogger.error(self.formatLogMessage('getVariable: ' + dimensionName + \" variables are not supported\"));\r\n                    _contextVariables[dimensionName] = null;\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            var levelObjectVariables = levelVariables[id];\r\n            if (levelObjectVariables !== undefined) {\r\n                _contextVariables[dimensionName] = levelObjectVariables;\r\n            } else {\r\n                _contextVariables[dimensionName] = null;\r\n                _internalLogger.error(self.formatLogMessage('getVariable: ' + dimensionName + ' with id ' + id + ' does not exist'));\r\n            }\r\n\r\n            return levelObjectVariables;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * gets a value of a promotion variable\r\n     * @param levelName \"Promotion\"|\"Tactic\"\r\n     * @param variableName name of the variable\r\n     */\r\n    var getPromotionVariable = function (levelName, variableName) {\r\n        var levelObjectVariables = getContextVariables(levelName);\r\n\r\n        if (levelObjectVariables !== null) {\r\n            var result = levelObjectVariables[variableName];\r\n            if (result !== undefined) {\r\n                return result;\r\n            } else {\r\n                _internalLogger.error(self.formatLogMessage('getVariable: variable ' + variableName + ' is not available for ' + levelName + ' with Id: ' + _node.getLabel()));\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n\r\n    /**\r\n     * Gets a value from the details of the Week dimension\r\n     * @param variableName name of the week variable\r\n     */\r\n    var getWeekVariable = function (variableName) {\r\n        if (_weekIndex > 0) {\r\n            if (_weekVariables != null) {\r\n                var week = _weekIndex - 1;  // skip the total\r\n                if (week in _weekVariables.details) {\r\n                    var weekVariablesCurrentWeek = _weekVariables.details[week];\r\n                    if (variableName in weekVariablesCurrentWeek) {\r\n                        return weekVariablesCurrentWeek[variableName];\r\n                    }\r\n                    else {\r\n                        _internalLogger.error(self.formatLogMessage('getVariable: variable ' + variableName + ' is not supported for week ' + week));\r\n                    }\r\n                }\r\n                else {\r\n                    _internalLogger.error(self.formatLogMessage('getVariable: no variables given for week ' + week));\r\n                }\r\n            }\r\n            else {\r\n                _internalLogger.error(self.formatLogMessage(\"getVariable: week variables are not supported\"));\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Determines the value of a variable\r\n     * @param {string} levelName The level on which the variable is defined\r\n     * @param {string} variableName The name of the variable\r\n     * @return {string|number|null|object}\r\n     */\r\n    this.getVariable = function (levelName, variableName) {\r\n        var result;\r\n\r\n        if (levelName === \"Week\") {\r\n            result = getWeekVariable(variableName);\r\n        }\r\n        else {\r\n            result = getPromotionVariable(levelName, variableName);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * calculates the fixed costs\r\n     * @param {number} Volume The volume of the current node\r\n     * @param {number} Volume$Tactic$Total The volume of the whole tactic\r\n     * @return {number|null}\r\n     */\r\n    this.calculateFixedCosts = function (Volume, Volume$Tactic$Total) {\r\n        var compensationModel = this.getVariable('Tactic', 'compensationmodel');\r\n        var calculatedCosts = null;\r\n\r\n        switch (compensationModel) {\r\n            case \"LumpSum\":\r\n                var amount = this.getVariable('Tactic', 'amount');\r\n                calculatedCosts = amount * Volume / Volume$Tactic$Total;\r\n                break;\r\n            case \"PerCase\":\r\n            case \"Percentage\":\r\n                _internalLogger.trace(this.formatLogMessage('calculateFixedCosts: Compensation model ' + compensationModel + ' is not supported'));\r\n                break;\r\n            default:\r\n                _internalLogger.warn(this.formatLogMessage('calculateFixedCosts: Compensation model ' + compensationModel + ' is not supported'));\r\n        }\r\n\r\n        return calculatedCosts;\r\n    };\r\n\r\n    /**\r\n     * calculates the variable costs\r\n     * @param {number} Volume The volume of the current node\r\n     * @param {number} Price The price of one item\r\n     * @return {number|null}\r\n     */\r\n    this.calculateVariableCosts = function (Volume, Price) {\r\n        var compensationModel = this.getVariable('Tactic', 'compensationmodel');\r\n        var amount = this.getVariable('Tactic', 'amount');\r\n        var calculatedCosts = null;\r\n\r\n        switch (compensationModel) {\r\n            case \"PerCase\":\r\n                calculatedCosts = Volume * amount;\r\n                break;\r\n            case \"Percentage\":\r\n                calculatedCosts = Volume * Price * amount / 100;\r\n                break;\r\n            case \"LumpSum\":\r\n                _internalLogger.trace(this.formatLogMessage('calculateVariableCosts: Compensation model ' + compensationModel + ' is not supported'));\r\n                break;\r\n            default:\r\n                _internalLogger.warn(this.formatLogMessage('calculateVariableCosts: Compensation model ' + compensationModel + ' is not supported'));\r\n        }\r\n\r\n        return calculatedCosts;\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the current measure\r\n     * @return {string}\r\n     */\r\n    this.getMeasureName = function () {\r\n        var measureName = \"\";\r\n        var measureDefinition = _node.getMeasureDefinition();\r\n\r\n        if (measureDefinition !== null) {\r\n            measureName = measureDefinition.name;\r\n        }\r\n\r\n        return measureName;\r\n    };\r\n\r\n    /**\r\n     * length of the intersection of two given timeframes (in weeks)\r\n     * @param {Date} weekStart start date of the first period\r\n     * @param {Date} weekEnd end date of the first period\r\n     * @param {Date} timeframeStart start date of the second period\r\n     * @param {Date} timeframeEnd end date of the second period\r\n     * @return {number|null}\r\n     */\r\n    var weekShareAux = function (weekStart, weekEnd, timeframeStart, timeframeEnd) {\r\n        var result = null;\r\n        var start = weekStart > timeframeStart ? weekStart : timeframeStart;\r\n        var end = weekEnd < timeframeEnd ? weekEnd : timeframeEnd;\r\n        if (start <= end) {\r\n            result = (1 + end.ACSF_dayDiff(start)) / 7;\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * fraction of the currently calculate calender week which belong to the timeframe of the current tactic or promotion\r\n     * @return {number}\r\n     */\r\n    this.weekShare = function () {\r\n        var level = this.getLevelName();\r\n        var weekValidFrom = new Date(this.getVariable('Week', 'datefrom'));\r\n        var weekValidThru = new Date(this.getVariable('Week', 'datethru'));\r\n        var levelName = level === 'measures' ? \"Promotion\" : \"Tactic\";\r\n        var validFrom = new Date(this.getVariable(levelName, 'datefrom'));\r\n        var validThru = new Date(this.getVariable(levelName, 'datethru'));\r\n\r\n        return weekShareAux(weekValidFrom, weekValidThru, validFrom, validThru);\r\n    };\r\n\r\n    /**\r\n     * Number of days from today to the currently calculated week\r\n     * @return {number}\r\n     */\r\n    this.daysUntilStart = function () {\r\n        return new Date(this.getVariable('Week', 'datefrom')).ACSF_dayDiff(new Date());\r\n    };\r\n\r\n    /**\r\n     * Is the currently calculated week the start week of the promotion/tactic?\r\n     * @return {Boolean}\r\n     */\r\n    this.isStartWeek = function () {\r\n        var weekStart = new Date(this.getVariable('Week', 'datefrom'));\r\n        var levelName = this.getLevelName() === 'measures' ? 'Promotion' : 'Tactic';\r\n        var timeframeStart = new Date(this.getVariable(levelName, 'datefrom'));\r\n        return weekStart <= timeframeStart && timeframeStart.ACSF_dayDiff(weekStart) <= 6;\r\n    };\r\n\r\n    /**\r\n     * Is the currently calculated week the end week of the promotion/tactic?\r\n     * @return {Boolean}\r\n     */\r\n    this.isEndWeek = function () {\r\n        var weekEnd = new Date(this.getVariable('Week', 'datethru'));\r\n        var levelName = this.getLevelName() === 'measures' ? 'Promotion' : 'Tactic';\r\n        var timeframeEnd = new Date(this.getVariable(levelName, 'datethru'));\r\n        return weekEnd >= timeframeEnd && timeframeEnd.ACSF_dayDiff(weekEnd) >= -6;\r\n    };\r\n    \r\n    /**\r\n     * @typedef {{}} TierDefinition\r\n     * @property {TierItem[]} tier\r\n     */\r\n    \r\n    /**\r\n     * @typedef {{}} TierItem\r\n     * @property {number} fromValue\r\n     * @property {number} toValue\r\n     * @property {number} amount\r\n     */\r\n    \r\n    /**\r\n     * Get the tiered rate of the tactic based on the given amount\r\n     * @param {string} variableName Name of the attribute in the tactic containing the tiered rates\r\n     * @param {number} amount\r\n     * @returns {number}\r\n     */\r\n    this.getTieredRate = function(variableName, amount) {\r\n        var tieredRate = 0;\r\n        \r\n        if(amount >= 0) {\r\n    \r\n            /**\r\n             * @type TierDefinition|null\r\n             */\r\n            var tierDefinition = this.getVariable('Tactic', variableName);\r\n    \r\n            if(tierDefinition !== null && typeof tierDefinition === \"object\") {\r\n                \r\n                var tiers = tierDefinition.tier;\r\n                if(tiers !== undefined && Array.isArray(tiers) && tiers.length > 0) {\r\n                    var matchingTierRateFound = false;\r\n                    \r\n                    for(var tierIndex = 0; tierIndex < tiers.length; tierIndex++) {\r\n                        var tier = tiers[tierIndex];\r\n                        \r\n                        if(tier.fromValue <= amount && amount < tier.toValue) {\r\n                            tieredRate = tier.amount;\r\n                            matchingTierRateFound = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    \r\n                    if(!matchingTierRateFound) {\r\n                        var highestTier = tiers[tiers.length - 1];\r\n                        if(amount >= highestTier.toValue) {\r\n                            tieredRate = highestTier.amount;\r\n                        }\r\n                    }\r\n                } else {\r\n                    _internalLogger.warn(this.formatLogMessage('Expected tiered rates!'));\r\n                }\r\n            }\r\n        }\r\n        \r\n        return tieredRate;\r\n    };\r\n    \r\n    /**\r\n     * Formats the message (prepends the measureName if available)\r\n     * @param {string} msg\r\n     * @return {string}\r\n     */\r\n    this.formatLogMessage = function (msg) {\r\n        var measureName = this.getMeasureName();\r\n\r\n        if (measureName !== \"\") {\r\n            msg = measureName + \": \" + msg;\r\n        }\r\n\r\n        return msg;\r\n    };\r\n\r\n    /**\r\n     * Logs a message with priority 'trace'\r\n     * @param {string} msg\r\n     */\r\n    this.trace = function (msg) {\r\n        _externalLogger.trace(this.formatLogMessage(msg));\r\n    };\r\n\r\n    /**\r\n     * Logs a message with priority 'trace'\r\n     * @param {string} msg\r\n     */\r\n    this.debug = function (msg) {\r\n        _externalLogger.debug(this.formatLogMessage(msg));\r\n    };\r\n\r\n    /**\r\n     * Logs a message with priority 'info'\r\n     * @param {string} msg\r\n     */\r\n    this.info = function (msg) {\r\n        _externalLogger.info(this.formatLogMessage(msg));\r\n    };\r\n\r\n    /**\r\n     * Logs a message with priority 'warn'\r\n     * @param {string} msg\r\n     */\r\n    this.warn = function (msg) {\r\n        _externalLogger.warn(this.formatLogMessage(msg));\r\n    };\r\n\r\n    /**\r\n     * Logs a message with priority 'error'\r\n     * @param {string} msg\r\n     */\r\n    this.error = function (msg) {\r\n        _externalLogger.error(this.formatLogMessage(msg));\r\n    };\r\n\r\n    /**\r\n     * Logs a message with priority 'fatal'\r\n     * @param {string} msg\r\n     */\r\n    this.fatal = function (msg) {\r\n        _externalLogger.fatal(this.formatLogMessage(msg));\r\n    };\r\n\r\n};\r\n\r\nmodule.exports.CalcHelper = CalcHelper;\r\n\n\n\n// WEBPACK FOOTER //\n// app/src/ui/calculationgrid/CalcHelper.js","\"use strict\";\r\n\r\nvar _ = require('lodash');\r\n\r\n/**\r\n * simple tree class to maintain filter\r\n * @constructor\r\n */\r\nvar SimpleTree = function () {\r\n    this.value = null;\r\n    this.children = [];\r\n    this.level = null;\r\n};\r\n\r\n/**\r\n * simple tree as a string\r\n * @param tree an instance of simple tree\r\n * @param indent {number} number of spaces used for indention\r\n */\r\nvar treeToString = function (tree, indent) {\r\n    var spaces = \" \".repeat(indent);\r\n    var result = spaces + tree.level + \": \" + tree.value + \"\\n\";\r\n    for (var i in tree.children) {\r\n        var child = tree.children[i];\r\n        result += treeToString(child, indent + 1);\r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * overwriting the toString function of simple trees\r\n */\r\nSimpleTree.prototype.toString = function () {\r\n    return treeToString(this, 0);\r\n};\r\n\r\n/**\r\n * converts a simple array to a filter array\r\n * @param {number[]} array the array\r\n * @returns {number[][]} e.g. [4,3,6,2] => [[0,4],[1,3],[2,6],[3,2]]\r\n */\r\nvar addIndex = function (array) {\r\n    var result = [];\r\n    for (var idx = 0; idx < array.length; idx++) {\r\n        result.push([idx, array[idx]]);\r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * helper to build a tree using lookups and filter\r\n * @param {number} levelIndex name of the root level\r\n * @param getNextLevelName {function} gives the next level name\r\n * @param levels {object[]} list of level name, items, startIndex, endIndex, dimensionIndex, hierarchyIndex\r\n * @param filterTrees {SimpleTree[]} list of filters\r\n */\r\nvar TreeBuilder = function (levelIndex, allLevels, filterTrees) {\r\n    /**\r\n     * get the indices of the children with a tree builder for the sub trees\r\n     * @ returns {Array} maps a index of a node to the tree builder for the sub tree\r\n     */\r\n    this.getChildren = function () {\r\n        var result = [];\r\n        var nextLevel = allLevels[levelIndex];\r\n        if (nextLevel === undefined) {\r\n            return result;\r\n        }\r\n        var nextLevelName = nextLevel.name;\r\n        for (var childIndex = nextLevel.startIndex; childIndex <= nextLevel.endIndex; childIndex++) {\r\n            var add = true;\r\n            var filterTreesRec = [];\r\n            for (var i = 0; i < filterTrees.length; i++) {\r\n                var filterTree = filterTrees[i];\r\n                var filterLevelName = filterTree.level;\r\n                if (nextLevelName == filterLevelName) {\r\n                    if (childIndex === -1 && filterTree.value === null) {\r\n                        // filter ignored\r\n                    } else if (childIndex in filterTree.children) {\r\n                        // filter applied\r\n                        var subtree = filterTree.children[childIndex];\r\n                        filterTreesRec.push(subtree);\r\n                    } else {\r\n                        // filter removed\r\n                        add = false;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    // filter forwarded\r\n                    filterTreesRec.push(filterTrees[i]);\r\n                }\r\n            }\r\n            if (add) {\r\n                // add\r\n                if (nextLevelName == undefined) {\r\n                    result.value = childIndex;\r\n                } else {\r\n                    result[childIndex] = new TreeBuilder(levelIndex + 1, allLevels, filterTreesRec);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};\r\n\r\n/**\r\n * helper to split the filters into equivalence classes defined by the relation f1[pos] == f2[pos]\r\n * @param {number[][]} filters\r\n * @param {number} pos indicator position\r\n * @returns {number[][][]}\r\n */\r\nvar partition = function (filters, pos) {\r\n    var subFilters = [];\r\n    for (var i = 0; i < filters.length; i++) {\r\n        var filter = filters[i];\r\n        var key = filter[pos];\r\n        if (key in subFilters) {\r\n            subFilters[key].push(filter);\r\n        }\r\n        else {\r\n            subFilters[key] = [filter];\r\n        }\r\n    }\r\n    return subFilters;\r\n};\r\n\r\n/**\r\n * recursive function to build up a filter as a (sub) tree\r\n * @param {number[][]} filters list of all allowed combinations\r\n * @param {[]} map defines in which order the items in filter must be considers\r\n * @param {string[]} levels name of the levels\r\n * @param {number} step skip the first items in the map\r\n * @returns {SimpleTree} tree defining the filter\r\n */\r\nvar createFilterTreeRec = function (filters, map, levels, step) {\r\n    var result = new SimpleTree();\r\n\r\n    if (step < levels.length) {\r\n        result.level = levels[step];\r\n    }\r\n\r\n    if (step < map.length) {\r\n        var pos = map[step];\r\n        var subFilters = partition(filters, pos);\r\n        for (var i = -1; i < subFilters.length; i++) {\r\n            var filter = subFilters[i];\r\n            if (filter !== undefined) {\r\n                var child = createFilterTreeRec(filter, map, levels, step + 1);\r\n                child.value = filter[0][pos];\r\n                result.children[i] = child;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * creates a filter tree based on the list of allowed combinations\r\n * @param {number[][]} filters list of all allowed combinations\r\n * @param {[]} map defines in which order the items in filter must be considers\r\n * @param {string[]} levels name of the levels\r\n * @return {SimpleTree}\r\n */\r\nvar createFilterTree = function (filters, map, levels) {\r\n    return createFilterTreeRec(filters, map, levels, 0);\r\n};\r\n\r\nmodule.exports.addIndex = addIndex;\r\nmodule.exports.createFilterTree = createFilterTree;\r\nmodule.exports.TreeBuilder = TreeBuilder;\r\n\n\n\n// WEBPACK FOOTER //\n// app/src/ui/calculationgrid/TreeBuilder.js","\"use strict\";\r\n/* globals CasException */\r\n\r\nvar _ = require(\"lodash\");\r\nvar benchmark = require('../benchmark');\r\n\r\n/**\r\n *\r\n * @type {CalcHelper}\r\n */\r\nvar calculationHelper = undefined;\r\nvar meta = undefined;\r\nvar dataMeta = undefined;\r\nvar log = undefined;\r\n\r\n/**\r\n *\r\n * @type {{UNKNOWN: number, ROOT: number, GROUPING: number, LEAF: number}}\r\n * @readonly\r\n * @enum {number}\r\n * @private\r\n */\r\nvar _NodeTypes = {\r\n    UNKNOWN: 0,\r\n    ROOT: 1,\r\n    GROUPING: 2,\r\n    LEAF: 3\r\n};\r\n\r\n/**\r\n * Gets the Data of all given leafs\r\n * @param {TreeNode[]} leafs Array of leafs to get\r\n * @returns {number[][]}\r\n * @Todo Check if this method could be reused (modified) for calculation + distribution\r\n */\r\nfunction getLeafDataRows(leafs) {\r\n    var leafData = [];\r\n\r\n    for (var i = 0; i < leafs.length; i++) {\r\n        var leaf = leafs[i];\r\n        if (leaf !== undefined) {\r\n            leafData[i] = leaf.getData();\r\n        }\r\n    }\r\n\r\n    return leafData;\r\n}\r\n\r\n/**\r\n * Sums up the the data in the specified column of all given Rows\r\n * @param {number[][]} dataRows Rows to be summed up\r\n * @param {number} columnIndex Index of the column to be summed up\r\n * @returns {number}\r\n * @Todo Check if this is needed / could be reused\r\n */\r\nfunction sumColumn(dataRows, columnIndex) {\r\n    var sum = 0;\r\n\r\n    for (var i = 0; i < dataRows.length; i++) {\r\n        var dataRow = dataRows[i];\r\n        if (dataRow !== undefined) {\r\n            if (dataRow[columnIndex] !== undefined && dataRow[columnIndex] !== null) {\r\n                sum += dataRow[columnIndex];\r\n            }\r\n        }\r\n    }\r\n\r\n    return sum;\r\n}\r\n\r\n/**\r\n * Calculates the TotalColumn\r\n * Considers if the totalColumn shall be displayed.\r\n */\r\nfunction calculateTotal(row, measureDefinition) {\r\n    if (measureDefinition !== null) {\r\n        // if the total calculation uses a formula, the correct value is already calculated in executeCalculationFormula()\r\n        if (!measureDefinition.isTotalCalculationBasedOnFormula()) {\r\n            row[0] = row.slice(1).reduce(measureDefinition.totalCalculation);\r\n        }\r\n    } else {\r\n        row[0] = null;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Gets a single column out of a 2D-Array a single row\r\n * @param {number[][]} rows\r\n * @param {number} columnId\r\n */\r\nfunction getColumnInRows(rows, columnId) {\r\n    var column = [];\r\n\r\n    for (var rowId = 0; rowId < rows.length; rowId++) {\r\n        if (rows[rowId] !== undefined) {\r\n            column.push(rows[rowId][columnId]);\r\n        }\r\n    }\r\n\r\n    return column;\r\n}\r\n\r\n/**\r\n * Breaks down a value over a column based on on a reference column\r\n * @param {TreeNode} originNode The source node where the distribution started to happen\r\n * @param {number} columnIndex The column within the DataRow where the value needs to be distributed across\r\n * @param {number|null} value The Value to be distributed\r\n * @param {number} measureIndex The Index of the KPI to be used as reference for the proportional distribution\r\n */\r\nvar breakDownProportionalTo = function (originNode, columnIndex, value, measureIndex) {\r\n    log.trace(\"breakDownProportionalTo() - Start\");\r\n    // Get all leafs\r\n    var leafs = originNode.getLeafs();\r\n    log.debug(\"breakDownProportionalTo() - Found \" + leafs.length + \"Leafs\");\r\n\r\n    // Get the reference KPI\r\n    var nodePosition = originNode.getPositionInTree();\r\n    var levelOfMeasures = meta.getLevelOfMeasures();\r\n    nodePosition[levelOfMeasures] = measureIndex;\r\n\r\n    // Todo: Check what would happen if the requested node does not exist! E.g. Tactic-Agnostic!\r\n    var proportionalNode = originNode.getNode(nodePosition);\r\n    var proportionalLeafs = proportionalNode.getLeafs();\r\n\r\n    var sumOfReferenceColumn = sumColumn(getLeafDataRows(proportionalLeafs), columnIndex);\r\n\r\n    distributeProportional(leafs, columnIndex, measureIndex, sumOfReferenceColumn, value, originNode);\r\n\r\n    log.trace(\"breakDownProportionalTo() - End\");\r\n};\r\n\r\n/**\r\n * Distributes a value over a column proportional to a reference column\r\n * @param {TreeNode[]} leafs Nodes which will be affected by the distribution\r\n * @param {number} columnIndex Identifier of the column where the distribution shall occur\r\n * @param {number} measureIndex Reference KPI\r\n * @param {number} sumOfReferenceColumn Sum of the reference column\r\n * @param {number|null} value The value which shall be distributed over all given leafs\r\n * @param {TreeNode} originNode The node where the Distribution started\r\n */\r\nvar distributeProportional = function (leafs, columnIndex, measureIndex, sumOfReferenceColumn, value, originNode) {\r\n    // FixMe: Will most likely need rework due to new concept\r\n    var levelOfMeasures = meta.getLevelOfMeasures();\r\n    for (var i = 0; i < leafs.length; i++) {\r\n        var leaf = leafs[i];\r\n        if (leaf !== undefined) {\r\n            var nodePosition = leaf.getPositionInTree();\r\n\r\n            if (value === null) {\r\n                leaf.setData(columnIndex, null);\r\n            }\r\n            else if (sumOfReferenceColumn !== 0 && value !== 0) {\r\n\r\n                nodePosition[levelOfMeasures] = measureIndex;\r\n                // Todo: Check what would happen if the requested node does not exist!\r\n                var referenceNode = originNode.getNode(nodePosition);\r\n\r\n                leaf.setData(columnIndex, referenceNode.getRawData()[columnIndex] / sumOfReferenceColumn * value);\r\n            }\r\n            else {\r\n                leaf.setData(columnIndex, 0);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n *\r\n * @param {TreeNode} sourceNode\r\n * @param {number|null} value\r\n */\r\nvar distributeViaCopy = function(sourceNode, value) {\r\n    var leafNodes = sourceNode.getLeafs();\r\n    \r\n    for(var leafIndex = 0; leafIndex < leafNodes.length; leafIndex++) {\r\n        var leafNode = leafNodes[leafIndex];\r\n        \r\n        if(leafNode !== undefined) {\r\n            for (var columnIndex = 1; columnIndex < dataMeta.noOfDataColumns; columnIndex++) {\r\n                leafNode.setData(columnIndex, value);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Class TreeNode\r\n * Used to store all information as part of a tree\r\n * @class\r\n * @param {number} globalId Unique Id of the node within the whole tree\r\n * @param {number} nodeId Id of the Node within the subtree\r\n * @param {number} dimensionId\r\n * @param {number} hierarchyLevel\r\n * @param {number} nodeLevel Level of the Node (Root is 0)\r\n * @param {_NodeTypes} nodeType\r\n * @param {TreeNode} parentNode Reference to the parent of this Node\r\n * @param {TreeNode} rootNode Reference to the root\r\n * @param {Object} measureDefinition\r\n * @constructor\r\n */\r\nvar TreeNode = function TreeNode(globalId, nodeId, dimensionId, hierarchyLevel, nodeLevel, nodeType, parentNode, rootNode, measureDefinition) {\r\n    this.id = globalId;\r\n    this.nodeId = nodeId;\r\n    this._dimensionId = dimensionId;\r\n    this._hierarchyLevel = hierarchyLevel;\r\n    this.parentNode = parentNode;\r\n    this.rootNode = rootNode;\r\n    this.nodeLevel = nodeLevel;\r\n    this.nodeType = nodeType;\r\n    this._children = [];\r\n    this._measureDefinition = measureDefinition;\r\n    this._manualChanges = [];\r\n\r\n    /**\r\n     * Sets a value in the specified column on this node\r\n     * Will be distributed down if this column is editable and this node a grouping-node\r\n     * @public\r\n     * @memberOf TreeNode\r\n     * @param {number} columnIndex\r\n     * @param {number|null} value\r\n     */\r\n    this.set = function (columnIndex, value) {\r\n        log.trace(\"set() - Start\");\r\n        benchmark.startMeasurement('Set');\r\n\r\n        if (value === undefined || value === _.trim(value)) {\r\n            value = null;\r\n        }\r\n\r\n        if (this.isEditable(columnIndex)) {\r\n    \r\n            this.addManualChange(columnIndex, value);\r\n    \r\n            if(columnIndex === 0) {\r\n                distributeViaCopy(this, value);\r\n            } else {\r\n                var measureDefinition = this.getMeasureDefinition();\r\n                var measureIndex = measureDefinition.distributionInformation.measureIndex;\r\n                // distribute the value proportional\r\n                breakDownProportionalTo(this, columnIndex, value, measureIndex);\r\n            }\r\n    \r\n            this.setDependingNodesDirty();\r\n        }\r\n        else {\r\n            throw new CasException.CasException(\"Trying to change content of non-editable KPI \");\r\n        }\r\n\r\n        log.trace(\"set() - End\");\r\n        benchmark.endMeasurement('Set');\r\n    };\r\n};\r\n\r\n\r\n/**\r\n * Id of the TreeNode. Must be globally unique!\r\n * @public\r\n * @memberOf TreeNode\r\n * @type {number}\r\n */\r\nTreeNode.prototype.id = -1;\r\n\r\n/**\r\n * Id of this node relative to the parentNode\r\n * @public\r\n * @memberOf TreeNode\r\n * @type {number}\r\n */\r\nTreeNode.prototype.nodeId = -1;\r\n\r\n/**\r\n * Reference to the parent of this node\r\n * @memberOf TreeNode\r\n * @public\r\n * @type {TreeNode}\r\n */\r\nTreeNode.prototype.parentNode = null;\r\n\r\n/**\r\n * Reference to the root of this tree\r\n * @public\r\n * @memberOf TreeNode\r\n * @type {TreeNode}\r\n */\r\nTreeNode.prototype.rootNode = null;\r\n\r\n/**\r\n * Level inside of the Tree\r\n * The RootNode has -1. The next 0 and so on\r\n * @public\r\n * @memberOf TreeNode\r\n * @type {number}\r\n */\r\nTreeNode.prototype.nodeLevel = -1;\r\n\r\n/**\r\n * NodeType of the TreeNode\r\n * @memberOf TreeNode\r\n * @type {_NodeTypes}\r\n */\r\nTreeNode.prototype.nodeType = _NodeTypes.UNKNOWN;\r\n\r\n/**\r\n * Indicates if the children of the TreeNode are LeafNodes\r\n * @memberOf TreeNode\r\n * @type {boolean}\r\n */\r\nTreeNode.prototype.childAreLeafs = false;\r\n\r\n/**\r\n * Collection of all direct children of this node\r\n * @private\r\n * @memberOf TreeNode\r\n * @type {TreeNode[]}\r\n */\r\nTreeNode.prototype._children = undefined;\r\n\r\n/**\r\n * Storage for the data in this node\r\n * @private\r\n * @memberOf TreeNode\r\n * @type {number[]|null}\r\n */\r\nTreeNode.prototype._data = null;\r\n\r\n/**\r\n * Dirty flag which indicates that the node must be recalculated\r\n * @private\r\n * @memberOf TreeNode\r\n * @type {boolean}\r\n */\r\nTreeNode.prototype._dirty = true;\r\n\r\n/**\r\n * References the definition of the Measure, if available\r\n * @private\r\n * @memberOf TreeNode\r\n * @type {null|Object}\r\n */\r\nTreeNode.prototype._measureDefinition = null;\r\n\r\n/**\r\n * Id of the Dimension this TreeNode represents\r\n * @memberOf TreeNode\r\n * @type {number}\r\n * @private\r\n */\r\nTreeNode.prototype._dimensionId = -1;\r\n\r\n/**\r\n * The level in the hierarchy\r\n *\r\n * 0 = Dimension\r\n * 1 = Dimension.Parent\r\n * 2 = Dimension.Parent.Parent ...\r\n * @memberOf TreeNode\r\n * @type {number}\r\n * @private\r\n */\r\nTreeNode.prototype._hierarchyLevel = -1;\r\n\r\n/**\r\n * Indicates if this object is the root or not\r\n * @public\r\n * @memberOf TreeNode\r\n * @returns {boolean}\r\n */\r\nTreeNode.prototype.isRoot = function () {\r\n    return this.nodeType === _NodeTypes.ROOT;\r\n};\r\n\r\n/**\r\n * Indicates if this object is a leaf or not\r\n * @public\r\n * @memberOf TreeNode\r\n * @returns {boolean}\r\n */\r\nTreeNode.prototype.isLeaf = function () {\r\n    return this.nodeType === _NodeTypes.LEAF;\r\n};\r\n\r\n/**\r\n * Indicates if this object is a grouping level or not\r\n * @public\r\n * @memberOf TreeNode\r\n * @returns {boolean}\r\n */\r\nTreeNode.prototype.isGrouping = function () {\r\n    return this.nodeType === _NodeTypes.GROUPING;\r\n};\r\n\r\n/**\r\n * Indicates if this node needs to be recalculated\r\n * @public\r\n * @memberOf TreeNode\r\n * @return {boolean}\r\n */\r\nTreeNode.prototype.isDirty = function () {\r\n    return this._dirty;\r\n};\r\n\r\n/**\r\n * Indicates if this node is a dimension\r\n * @public\r\n * @memberOf TreeNode\r\n * @return {boolean} TRUE this node is a dimension. FALSE this node is a HierarchyNode\r\n */\r\nTreeNode.prototype.isDimensionNode = function isDimensionNode() {\r\n    return this._hierarchyLevel === 0;\r\n};\r\n\r\n/**\r\n * Indicates if this node is a hierarchy node\r\n * @public\r\n * @memberOf TreeNode\r\n * @return {boolean} TRUE this node is a HierarchyNode. FALSE this node is a dimension\r\n */\r\nTreeNode.prototype.isHierarchyNode = function isHierarchyNode() {\r\n    return this._hierarchyLevel > 0;\r\n};\r\n\r\n/**\r\n * Gets the Level in the hierarchy\r\n * @public\r\n * @memberOf TreeNode\r\n * @return {number}\r\n */\r\nTreeNode.prototype.getHierarchyLevel = function getHierarchyLevel() {\r\n    return this._hierarchyLevel;\r\n};\r\n\r\n/**\r\n * Gets the Id of the dimension this node represents\r\n * @public\r\n * @memberOf TreeNode\r\n * @return {number}\r\n */\r\nTreeNode.prototype.getDimensionId = function getDimensionId() {\r\n    return this._dimensionId;\r\n};\r\n\r\n/**\r\n * Indicates if this node is an imaginary/dummy node because a level/dimension has been skipped\r\n * @public\r\n * @memberOf TreeNode\r\n * @return {boolean}\r\n */\r\nTreeNode.prototype.isImaginary = function () {\r\n    return this.nodeId === -1;\r\n};\r\n\r\n/**\r\n * Indicates if this node has an imaginary childNode\r\n * @public\r\n * @return {boolean}\r\n */\r\nTreeNode.prototype.hasImaginaryChild = function () {\r\n    return -1 in this._children;\r\n};\r\n\r\n/**\r\n * Gets the Label of the current node\r\n * @public\r\n * @memberOf TreeNode\r\n * @return {string}\r\n */\r\nTreeNode.prototype.getLabel = function getLabel() {\r\n    // FixMe: Remove this!\r\n    if (this.isRoot()) {\r\n        return \"Root\";\r\n    }\r\n\r\n    var dimensionName = meta.axis.y[this._dimensionId];\r\n    var label = \"missing Information\";\r\n\r\n    if (dimensionName !== \"measures\") {\r\n        var dimensionInformation = dataMeta.getDimensionByName(dimensionName);\r\n\r\n        for (var hierarchyLevelIndex = 0; hierarchyLevelIndex < this._hierarchyLevel; hierarchyLevelIndex++) {\r\n            // go up the hierarchy if necessary\r\n            dimensionInformation = dimensionInformation.hierarchy;\r\n        }\r\n\r\n        var lookUps = dimensionInformation.lookups;\r\n        label = lookUps[this.nodeId];\r\n    } else {\r\n        label = meta.measures[this.nodeId].name;\r\n    }\r\n\r\n    return label;\r\n};\r\n\r\n/**\r\n * Gets the level of this node within the Tree\r\n * @public\r\n * @memberOf TreeNode\r\n * @return {number}\r\n */\r\nTreeNode.prototype.getLevel = function () {\r\n    return this.nodeLevel;\r\n};\r\n\r\n/**\r\n * Gets all labels for the current node (row in the grid)\r\n * @public\r\n * @memberOf TreeNode\r\n * @returns {string[]}\r\n */\r\nTreeNode.prototype.getLabels = function () {\r\n    var labels = [];\r\n\r\n    var node = this;\r\n    while (!node.isRoot()) {\r\n        labels.unshift(node.getLabel());\r\n        node = node.parentNode;\r\n    }\r\n\r\n    return labels;\r\n};\r\n\r\n/**\r\n * Gets all ChildRows (recursively!)\r\n * @private\r\n * @memberOf TreeNode\r\n * @returns {number[][]}\r\n */\r\nTreeNode.prototype.getChildRows = function () {\r\n    var childRows = [];\r\n\r\n    if (this.childAreLeafs) {\r\n        childRows = this._children.map(function (row) {\r\n            return row.calculate();\r\n        });\r\n\r\n        if (this.hasImaginaryChild()) {\r\n            childRows.push(this._children[-1].calculate());\r\n        }\r\n\r\n    } else {\r\n        childRows = this._children.map(function (child) {\r\n            return child.aggregate();\r\n        });\r\n\r\n        if (this.hasImaginaryChild()) {\r\n            childRows.push(this._children[-1].aggregate());\r\n        }\r\n    }\r\n    return childRows;\r\n};\r\n\r\n/**\r\n * Indicates if the given column is editable\r\n * @param {number} columnIndex id of the column\r\n * @public\r\n * @memberOf TreeNode\r\n * @returns {boolean}\r\n */\r\nTreeNode.prototype.isEditable = function (columnIndex) {\r\n    var isEditable = false;\r\n    \r\n    var measureDefinition = this.getMeasureDefinition();\r\n    \r\n    if (measureDefinition) {\r\n        \r\n        if (measureDefinition.isEditable) {\r\n            if (columnIndex > 0) {\r\n                if (columnIndex < dataMeta.noOfDataColumns) {\r\n                    isEditable = true;\r\n                } else {\r\n                    log.warn(\"Out of upper bounds!\");\r\n                }\r\n            } else if (columnIndex === 0) {\r\n                isEditable = true;\r\n            } else {\r\n                log.warn(\"Out of lower bounds!\");\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        log.warn(\"Cannot edit above KPI-Level!\");\r\n    }\r\n    \r\n    return isEditable;\r\n};\r\n\r\n/**\r\n * Indicates if the given column is editable and if it is allowed\r\n *\r\n * Additionally checks if the cell is editable in the past or not.\r\n * @param {number} columnIndex id of the column\r\n * @public\r\n * @memberOf TreeNode\r\n * @returns {boolean}\r\n */\r\nTreeNode.prototype.isEditAllowed = function (columnIndex) {\r\n    var isEditAllowed = false;\r\n    var isEditableColumn = this.isEditable(columnIndex);\r\n    \r\n    if (isEditableColumn) {\r\n        var measureDefinition = this.getMeasureDefinition();\r\n        \r\n        if(measureDefinition.distributionInformation.mode === \"week\") {\r\n            // Edits in edit-mode week are only allowed in weekly columns, not in the total column.\r\n            if(columnIndex > 0) {\r\n                if (measureDefinition.distributionInformation.enablePastWeeks) {\r\n                    isEditAllowed = true;\r\n                } else {\r\n                    isEditAllowed = dataMeta.currentWeekIndex <= columnIndex;\r\n                }\r\n            }\r\n        } else {\r\n            // Edits in edit-mode total are only allowed in the total column.\r\n            isEditAllowed = columnIndex === 0;\r\n        }\r\n    }\r\n    \r\n    return isEditAllowed;\r\n};\r\n\r\n/**\r\n * Gets the current position in the tree.\r\n * Can be used to identify the GroupingNames\r\n * @example root = [], root.child[3].child[5] = [3,5]...\r\n * @public\r\n * @memberOf TreeNode\r\n * @returns {number[]}\r\n */\r\nTreeNode.prototype.getPositionInTree = function () {\r\n    var position = [];\r\n    if (!this.isRoot()) {\r\n        position = this.parentNode.getPositionInTree();\r\n        position.push(this.nodeId);\r\n    }\r\n\r\n    return position;\r\n};\r\n\r\n/**\r\n * Adds a childNode to the current Node\r\n * Uses the nodeId (not the global unique!) as index\r\n * @public\r\n * @memberOf TreeNode\r\n * @param {TreeNode} child Node to be added as child to the current Node\r\n * @param {number} child.nodeId Id of the node (IndexReference in the dataTable\r\n */\r\nTreeNode.prototype.addChild = function (child) {\r\n    this._children[child.nodeId] = child;\r\n};\r\n\r\n/**\r\n * Gets a childNode based on its relative Id\r\n *\r\n * To use the globalId use Tree.getChild(id)\r\n * @public\r\n * @memberOf TreeNode\r\n * @see Tree.getChild(id) Use Tree.getChild(id)\r\n * @param {number} nodeId\r\n * @returns {TreeNode|undefined}\r\n */\r\nTreeNode.prototype.getChildNode = function (nodeId) {\r\n    return this._children[nodeId];\r\n};\r\n\r\n/**\r\n * Indicates if this object has child objects or not (includes Imaginary children)\r\n * @public\r\n * @memberOf TreeNode\r\n * @returns {boolean}\r\n */\r\nTreeNode.prototype.hasChildren = function () {\r\n    return this._children.length > 0 || this.hasImaginaryChild();\r\n};\r\n\r\n/**\r\n * Gets all children of this TreeNode\r\n * @public\r\n * @memberOf TreeNode\r\n * @return {TreeNode[]}\r\n */\r\nTreeNode.prototype.getChildren = function () {\r\n    var children;\r\n\r\n    if (this.hasImaginaryChild() && this._children.length > 0) {\r\n        log.error(\"Not Implemented: Imaginary and non-Imaginary Children found!\");\r\n        children = [];\r\n    }\r\n    else if (this.hasImaginaryChild()) {\r\n        log.debug(\"getChildren: Skipping Imaginary Child.\");\r\n        children = this._children[-1].getChildren();\r\n    }\r\n    else {\r\n        children = this._children;\r\n    }\r\n\r\n    return children;\r\n};\r\n\r\n/**\r\n * Indicates if the Children of this node should be shown in the UI\r\n * @public\r\n * @memberOf TreeNode\r\n * @return {boolean}\r\n */\r\nTreeNode.prototype.showChildren = function () {\r\n    return !this.isLeaf();\r\n};\r\n\r\n/**\r\n * Gets the number of digits for correct rounding in the UI\r\n * @public\r\n * @memberOf TreeNode\r\n * @returns {number} The number of digits if specified else 2 digits as fallback\r\n */\r\nTreeNode.prototype.getRounding = function () {\r\n    var roundingDigits = 2;\r\n    var measureDefinition = this.getMeasureDefinition();\r\n\r\n    if (measureDefinition !== null) {\r\n        roundingDigits = measureDefinition.display.round;\r\n    }\r\n\r\n    return roundingDigits;\r\n};\r\n\r\n/**\r\n * Sets the data for the specified column\r\n * Assumes that the totalColumn is at index 0!\r\n *\r\n * @memberOf TreeNode\r\n * @param {number} index Position in the Data\r\n * @param {number|null} value Value to be set\r\n * @throws {Error} Throws an error if the index is out of bounds.\r\n * @throws {Error} Throws an error if initData(size) is not called before setting the data.\r\n */\r\nTreeNode.prototype.setData = function (index, value) {\r\n    if (index >= 0 && index <= dataMeta.noOfDataColumns) {\r\n        this._data[index] = value;\r\n    } else if (index < 0) {\r\n        throw new CasException.CasException(\"Out of Lower-Bounds!\");\r\n    } else {\r\n        throw new CasException.CasException(\"Out of Upper-Bounds!\");\r\n    }\r\n};\r\n\r\n/**\r\n * Sets the raw Data\r\n * @memberOf TreeNode\r\n * @param {(number|null)[]} rawData\r\n */\r\nTreeNode.prototype.setRawData = function setRawData(rawData) {\r\n    if (rawData === undefined) {\r\n        log.warn(\"inserting undefined data\");\r\n    }\r\n\r\n    if (this.isLeaf()) {\r\n        rawData.unshift(null); // add total column\r\n        this._data = rawData;\r\n    } else {\r\n        throw new CasException.CasException(\"Not implemented: Cannot set data on a none-leaf TreeNode!\");\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the raw Data of a leaf\r\n *\r\n * Should only be called on Leaf-Level!\r\n * Should not be called on calculated nodes!\r\n * @memberOf TreeNode\r\n * @returns (number[])\r\n */\r\nTreeNode.prototype.getRawData = function () {\r\n    //benchmark.startMeasurement('getRawData');\r\n    log.trace(\"getRawData() - Start\");\r\n    var computedRowData;\r\n\r\n    if (this.isLeaf()) {\r\n        computedRowData = this._data;\r\n    }\r\n    else {\r\n        log.warn(\"getRawData() - Unexpected Call on level: \" + this.nodeType.toString() + \" in KPI: \" + this.getMeasureDefinition().name);\r\n        computedRowData = createAndFillArray(dataMeta.noOfDataColumns, null);\r\n    }\r\n\r\n    log.trace(\"getRawData() - End\");\r\n    //benchmark.endMeasurement('getRawData');\r\n    return computedRowData;\r\n};\r\n\r\n/**\r\n * Gets the MeasureDefinition of this Node\r\n * Returns null if the measure is below the current level\r\n * @public\r\n * @memberOf TreeNode\r\n * @returns {Object|null}\r\n */\r\nTreeNode.prototype.getMeasureDefinition = function () {\r\n    return this._measureDefinition;\r\n};\r\n\r\n/**\r\n * Gets all (calculated) rows which are referenced by the current Node on the current level\r\n * @private\r\n * @memberOf TreeNode\r\n * @param {Object} measureDefinition\r\n * @return {number[][]}\r\n */\r\nTreeNode.prototype.getReferencedRowsForCalculation = function (measureDefinition) {\r\n    var posInTree = this.getPositionInTree();\r\n    var measureLevel = meta.getLevelOfMeasures();\r\n\r\n    // get all referenced Rows\r\n    var argRowList = [];\r\n    for (var i = 0; i < measureDefinition.args.length; i++) {\r\n        var functionArgument = measureDefinition.args[i];\r\n        // Copy the nodePosition as it could be truncated later on for KPIs on a higher level\r\n        var nodePosition = posInTree.slice();\r\n        nodePosition[measureLevel] = functionArgument.measureIndex;\r\n\r\n        if (functionArgument.isComplexArgument) {\r\n            // manipulate the nodePosition the get values on a higher level if needed\r\n            //nodePosition = nodePosition.slice(0, functionArgument.levelIndex + 1);\r\n            var levelIndex = dataMeta.getLevelIndex(functionArgument.levelName);\r\n            nodePosition = nodePosition.slice(0, levelIndex + 1);\r\n        }\r\n\r\n        var node = this.getNode(nodePosition);\r\n\r\n        if (node !== undefined) {\r\n            var data = node.getData();\r\n\r\n            if (functionArgument.isComplexArgument && functionArgument.useTotal) {\r\n                // Use the TotalValue for all weeks\r\n                data = createAndFillArray(dataMeta.noOfDataColumns, data[0]);\r\n            }\r\n\r\n            argRowList[i] = data;\r\n        }\r\n        else {\r\n            // Use a fallback as no node could be found\r\n            argRowList[i] = createAndFillArray(dataMeta.noOfDataColumns, null);\r\n        }\r\n    }\r\n    return argRowList;\r\n};\r\n\r\n/**\r\n * Executes the specified calculation formula\r\n * @private\r\n * @memberOf TreeNode\r\n * @param {Object} measureDefinition\r\n * @param {number[][]} argRowList\r\n * @return {number[]}\r\n */\r\nTreeNode.prototype.executeCalculationFormula = function (measureDefinition, argRowList) {\r\n    var resultRow = [];\r\n    var funcArguments = [];\r\n\r\n    calculationHelper.setNode(this);\r\n\r\n    var startIndex = 1;\r\n    var weekIterator;\r\n    if (measureDefinition.isTotalCalculationBasedOnFormula()) {\r\n        // calculate the total the same way as the weekly values\r\n        startIndex = 0;\r\n    }\r\n\r\n    var numberOfArguments = measureDefinition.args.length;\r\n    benchmark.startMeasurement('executeCalculation.' + measureDefinition.name);\r\n\r\n    switch(numberOfArguments) {\r\n        case 0:\r\n            benchmark.startMeasurement('executeCalculationWith0Arguments');\r\n            for (weekIterator = startIndex; weekIterator < dataMeta.noOfDataColumns; weekIterator++) {\r\n                calculationHelper.setWeekIndex(weekIterator);\r\n                resultRow[weekIterator] = measureDefinition.func(calculationHelper);\r\n            }\r\n            benchmark.endMeasurement('executeCalculationWith0Arguments');\r\n            break;\r\n\r\n        case 1:\r\n            benchmark.startMeasurement('executeCalculationWith1Arguments');\r\n            for (weekIterator = startIndex; weekIterator < dataMeta.noOfDataColumns; weekIterator++) {\r\n                calculationHelper.setWeekIndex(weekIterator);\r\n                resultRow[weekIterator] = measureDefinition.func(calculationHelper, undefinedToNull(argRowList[0][weekIterator]));\r\n            }\r\n            benchmark.endMeasurement('executeCalculationWith1Arguments');\r\n            break;\r\n\r\n        case 2:\r\n            benchmark.startMeasurement('executeCalculationWith2Arguments');\r\n            for (weekIterator = startIndex; weekIterator < dataMeta.noOfDataColumns; weekIterator++) {\r\n                calculationHelper.setWeekIndex(weekIterator);\r\n                resultRow[weekIterator] = measureDefinition.func(calculationHelper, undefinedToNull(argRowList[0][weekIterator]), undefinedToNull(argRowList[1][weekIterator]));\r\n            }\r\n            benchmark.endMeasurement('executeCalculationWith2Arguments');\r\n            break;\r\n\r\n        case 3:\r\n            benchmark.startMeasurement('executeCalculationWith3Arguments');\r\n            for (weekIterator = startIndex; weekIterator < dataMeta.noOfDataColumns; weekIterator++) {\r\n                calculationHelper.setWeekIndex(weekIterator);\r\n                resultRow[weekIterator] = measureDefinition.func(calculationHelper, undefinedToNull(argRowList[0][weekIterator]), undefinedToNull(argRowList[1][weekIterator]), undefinedToNull(argRowList[2][weekIterator]));\r\n            }\r\n            benchmark.endMeasurement('executeCalculationWith3Arguments');\r\n            break;\r\n\r\n        default:\r\n            funcArguments.push(calculationHelper);\r\n            for (weekIterator = startIndex; weekIterator < dataMeta.noOfDataColumns; weekIterator++) {\r\n                calculationHelper.setWeekIndex(weekIterator);\r\n                for (var j = 0; j < numberOfArguments; j++) {\r\n                    funcArguments[j + 1] = undefinedToNull(argRowList[j][weekIterator]);\r\n                }\r\n                benchmark.startMeasurement('applyFunction.' + measureDefinition.name);\r\n                resultRow[weekIterator] = measureDefinition.func.apply(this, funcArguments);\r\n\r\n                benchmark.endMeasurement('applyFunction.' + measureDefinition.name);\r\n            }\r\n    }\r\n\r\n    benchmark.endMeasurement('executeCalculation.' + measureDefinition.name);\r\n\r\n    return resultRow;\r\n};\r\n\r\n/**\r\n * Converts a value to null if it is undefined\r\n * @param value\r\n * @returns {*}\r\n */\r\nfunction undefinedToNull(value) {\r\n    if(value === undefined) {\r\n        return null;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\n/**\r\n * Create an array and fills it with the specified value\r\n * @param {number} size\r\n * @param {number|null} value\r\n * @returns {Array}\r\n */\r\nfunction createAndFillArray(size, value) {\r\n    var result = new Array(size);\r\n    _.fill(result, value);\r\n    return result;\r\n}\r\n\r\n/**\r\n * Gets the values of the row and calculates computed fields if necessary\r\n * If this method is called on a non-leaf node, the result will be undefined\r\n * @private\r\n * @memberOf TreeNode\r\n */\r\nTreeNode.prototype.calculate = function () {\r\n    log.debug(\"calculate() - Start\");\r\n    var row;\r\n\r\n    var measureDefinition = this.getMeasureDefinition();\r\n\r\n    if (!this.isDirty()) {\r\n        benchmark.startMeasurement('calculate.' + measureDefinition.name + '.Cached');\r\n        row = this._data;\r\n        benchmark.endMeasurement('calculate.' + measureDefinition.name + '.Cached');\r\n    } else {\r\n        benchmark.startMeasurement('calculate.' + measureDefinition.name + '.NotCached');\r\n\r\n        if (measureDefinition && measureDefinition.computed) {\r\n            // Calculates the current row if it depends on other measures.\r\n            var argRowList = this.getReferencedRowsForCalculation(measureDefinition);\r\n            row = this.executeCalculationFormula(measureDefinition, argRowList);\r\n        }\r\n        else {\r\n            // Gets the basic data in the row without any calculation\r\n            row = this.getRawData();\r\n        }\r\n\r\n        calculateTotal(row, measureDefinition);\r\n\r\n        this._data = row;\r\n        this.setDirty(false);\r\n        benchmark.endMeasurement('calculate.' + measureDefinition.name + '.NotCached');\r\n    }\r\n\r\n    log.debug(\"calculate() - End\");\r\n    return row;\r\n};\r\n\r\n/**\r\n * Sets the node to dirty dependent on the flag\r\n * @private\r\n * @memberOf TreeNode\r\n * @param {Boolean} flag\r\n */\r\nTreeNode.prototype.setDirty = function (flag) {\r\n    this._dirty = flag;\r\n};\r\n\r\n/**\r\n * Aggregates all rows below to a single row based on the measureDefinition\r\n * @private\r\n * @memberOf TreeNode\r\n * @returns {number[]}\r\n */\r\nTreeNode.prototype.aggregate = function () {\r\n    var measureDefinition = this.getMeasureDefinition();\r\n\r\n    var noColumns = dataMeta.noOfDataColumns;\r\n    var aggregationResult;\r\n\r\n    if (!this._dirty) {\r\n        aggregationResult = this._data;\r\n    }\r\n    else {\r\n        if (measureDefinition === null) {\r\n            // if measures is not on top level it could be below\r\n            // Example: Tactic,measures,PrdGroup,Prd => Aggregating the measures up to TacticLevel does not make any sense!\r\n            aggregationResult = createAndFillArray(noColumns, null);\r\n        }\r\n        else {\r\n            if (measureDefinition.isAggregationBasedOnFormula()) {\r\n                benchmark.startMeasurement(\"aggregate.BasedOnFormula\");\r\n                aggregationResult = this.calculate();\r\n                benchmark.endMeasurement(\"aggregate.BasedOnFormula\");\r\n            }\r\n            else {\r\n                benchmark.startMeasurement(\"aggregate.GetChildRows\");\r\n                var childRows = this.getChildRows();\r\n                benchmark.endMeasurement(\"aggregate.GetChildRows\");\r\n\r\n                benchmark.startMeasurement(\"aggregate.Standard\");\r\n                aggregationResult = [];\r\n                // Aggregate up to the current level\r\n                // Iterate of each column of the 2-dim-Array\r\n                for (var columnIndex = 0; columnIndex < noColumns; columnIndex++) {\r\n                    var calcRow = getColumnInRows(childRows, columnIndex);\r\n\r\n                    // Aggregate the column\r\n                    if (calcRow.length > 0) {\r\n                        aggregationResult[columnIndex] = calcRow.reduce(measureDefinition.aggregation);\r\n                    }\r\n                    else {\r\n                        aggregationResult[columnIndex] = null;\r\n                    }\r\n                }\r\n                calculateTotal(aggregationResult, measureDefinition);\r\n                benchmark.endMeasurement(\"aggregate.Standard\");\r\n            }\r\n        }\r\n\r\n        this._data = aggregationResult;\r\n        this.setDirty(false);\r\n    }\r\n\r\n    return aggregationResult;\r\n};\r\n\r\n/**\r\n * Gets the data of a row\r\n * @public\r\n * @memberOf TreeNode\r\n * @throws CasException If the function is called on another level than Leaf or GroupingLevel\r\n * @return {number[]}\r\n */\r\nTreeNode.prototype.getData = function () {\r\n    var result;\r\n\r\n    if (this.isRoot()) {\r\n        throw new CasException(\"Invalid Operations. Use Tree.getHeader() to get the header\");\r\n    }\r\n    else if (this.isLeaf()) {\r\n        result = this.calculate();\r\n    }\r\n    else if (this.isGrouping()) {\r\n        result = this.aggregate();\r\n    }\r\n    else {\r\n        throw new CasException(\"Invalid NodeType: '\" + this.nodeType + \"'\");\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Sets this node and all of its children to dirty to trigger a recalculation\r\n * @private\r\n * @memberOf TreeNode\r\n */\r\nTreeNode.prototype.setChildrenDirty = function () {\r\n    this.setDirty(true);\r\n    for (var i = -1; i < this._children.length; i++) {\r\n        var child = this._children[i];\r\n\r\n        if (child !== undefined) {\r\n            child.setChildrenDirty();\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Sets all parents (ancestors) dirty to trigger a recalculation\r\n */\r\nTreeNode.prototype.setParentsDirty = function () {\r\n    var parent = this.parentNode;\r\n\r\n    if (!parent.isRoot()) {\r\n        parent.setDirty(true);\r\n        parent.setParentsDirty();\r\n    }\r\n};\r\n\r\n/**\r\n * Gets a Node in the Tree via its relative Ids\r\n * @public\r\n * @memberOf TreeNode\r\n * @param {number[]} positionInTree\r\n * @returns {TreeNode|undefined}\r\n */\r\nTreeNode.prototype.getNode = function (positionInTree) {\r\n    var currentNode = this.isRoot() ? this : this.rootNode;\r\n\r\n    for (var i = 0; i < positionInTree.length; i++) {\r\n        if (currentNode !== null && currentNode !== undefined) {\r\n            if (currentNode.hasImaginaryChild()) {\r\n                currentNode = currentNode.getChildNode(-1);\r\n            }\r\n            else {\r\n                currentNode = currentNode.getChildNode(positionInTree[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return currentNode;\r\n};\r\n\r\n/**\r\n * Gets all leaf nodes below this node\r\n * @memberOf TreeNode\r\n * @returns {TreeNode[]}\r\n */\r\nTreeNode.prototype.getLeafs = function () {\r\n    log.debug(\"getLeafs() - Start\");\r\n    var leafs = [];\r\n\r\n    if (this.isLeaf()) {\r\n        leafs.push(this);\r\n    }\r\n    else if (this.childAreLeafs) {\r\n        leafs = leafs.concat(this._children);\r\n    }\r\n    else {\r\n        for (var i = -1; i < this._children.length; i++) {\r\n            var leaf = this._children[i];\r\n\r\n            if (leaf !== undefined) {\r\n                leafs = leafs.concat(leaf.getLeafs());\r\n            }\r\n        }\r\n    }\r\n\r\n    log.debug(\"getLeafs() - End\");\r\n    return leafs;\r\n};\r\n\r\n/**\r\n * Indicates if this node should be displayed.\r\n * Mainly this depends on the measure.\r\n * @public\r\n * @memberOf TreeNode\r\n * @returns {boolean}\r\n */\r\nTreeNode.prototype.showInUI = function () {\r\n    var showInUI = true;\r\n    var measureDefinition = this.getMeasureDefinition();\r\n\r\n    if (measureDefinition !== null) {\r\n        showInUI = measureDefinition.display.enabled;\r\n    }\r\n\r\n    return showInUI;\r\n};\r\n\r\n/**\r\n * Sets all dependent Nodes to dirty to trigger a recalculation\r\n * @private\r\n * @memberOf TreeNode\r\n */\r\nTreeNode.prototype.setDependingNodesDirty = function () {\r\n\r\n    // set this node and all siblings and children to dirty\r\n    if (!this.isDirty()) {\r\n        this.setChildrenDirty();\r\n        this.setParentsDirty();\r\n\r\n        var positionInTree = this.getPositionInTree();\r\n        var levelOfMeasures = meta.getLevelOfMeasures();\r\n\r\n        var measurePositionInTree = positionInTree.slice(0, levelOfMeasures + 1);\r\n        var measureDefinition = this.getMeasureDefinition();\r\n\r\n        for (var i = 0; i < measureDefinition.dependingMeasures.length; i++) {\r\n            if (measureDefinition.dependingMeasures[i] !== undefined) {\r\n                var dependentMeasure = measureDefinition.dependingMeasures[i];\r\n\r\n                measurePositionInTree[levelOfMeasures] = dependentMeasure.id;\r\n\r\n                var dependentNode = this.getNode(measurePositionInTree);\r\n                dependentNode.setDependingNodesDirty();\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Adds a manual change to the history\r\n *\r\n * Clears all changes below the current level\r\n * @private\r\n * @memberOf TreeNode\r\n * @param {number} index\r\n * @param {number|null} value\r\n */\r\nTreeNode.prototype.addManualChange = function (index, value) {\r\n    this._manualChanges[index] = value;\r\n    \r\n    if(index === 0) {\r\n        for(var columnIndex = 0; columnIndex < dataMeta.noOfDataColumns; columnIndex++) {\r\n            this.clearDescendantChanges(columnIndex);\r\n        }\r\n    } else {\r\n        this.clearDescendantChanges(index);\r\n    }\r\n};\r\n\r\n/**\r\n * Gets all manual changes (recursively).\r\n * @public\r\n * @memberOf TreeNode\r\n * @param {Object} parentIdentifiers\r\n * @return {Array}\r\n */\r\nTreeNode.prototype.getManualChanges = function (parentIdentifiers) {\r\n    var manualChanges = [];\r\n    var measureDefinition = this.getMeasureDefinition();\r\n    var identifiers = _.clone(parentIdentifiers, false);\r\n\r\n    if (measureDefinition === null || measureDefinition.isEditable) {\r\n        if (!this.isRoot()) {\r\n            var dimensionName = meta.axis.y[this._dimensionId];\r\n            var currentLabel = this.getLabel();\r\n\r\n            identifiers[dimensionName] = currentLabel;\r\n\r\n            for (var dataIndex = 0; dataIndex < this._manualChanges.length; dataIndex++) {\r\n                var value = this._manualChanges[dataIndex];\r\n\r\n                if (value !== undefined) {\r\n\r\n                    var manualChange = {dimensions: _.clone(identifiers, false), value: value};\r\n                    manualChange.dimensions[meta.axis.x] = dataIndex; // FixMe\r\n\r\n                    manualChanges.push(manualChange);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (var childIndex = -1; childIndex < this._children.length; childIndex++) {\r\n            var childNode = this._children[childIndex];\r\n\r\n            if (childNode !== undefined) {\r\n                manualChanges = manualChanges.concat(childNode.getManualChanges(identifiers));\r\n            }\r\n        }\r\n    }\r\n\r\n    return manualChanges;\r\n};\r\n\r\n/**\r\n * Clears the manual changes of all descendants (recursively).\r\n * @private\r\n * @memberOf TreeNode\r\n * @param {number} index Index where the clearing of the change shall happen.\r\n */\r\nTreeNode.prototype.clearDescendantChanges = function (index) {\r\n    if (this.hasChildren()) {\r\n        for (var childIndex = -1; childIndex < this._children.length; childIndex++) {\r\n            var childNode = this._children[childIndex];\r\n\r\n            if (childNode !== undefined) {\r\n                childNode.clearManualChange(index);\r\n                childNode.clearDescendantChanges(index);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Clears a single manual change\r\n * @private\r\n * @memberOf TreeNode\r\n * @param {number} index Index where the clearing of the change shall happen.\r\n */\r\nTreeNode.prototype.clearManualChange = function (index) {\r\n    delete this._manualChanges[index];\r\n};\r\n\r\n/**\r\n * Indicates if this node has any manual changes\r\n * @memberOf TreeNode\r\n * @return {boolean}\r\n */\r\nTreeNode.prototype.hasManualChanges = function () {\r\n    return this._manualChanges.length > 0;\r\n};\r\n\r\n/**\r\n * Sets the Logging-Object\r\n * @param logger\r\n */\r\nfunction setLogger(logger) {\r\n    log = logger.child({widget_type: \"TreeNode\"});\r\n}\r\n\r\n/**\r\n * Sets the CalculationHelper Object\r\n * @param {CalcHelper} calcHelper\r\n */\r\nfunction setCalcHelper(calcHelper) {\r\n    calculationHelper = calcHelper;\r\n}\r\n\r\n/**\r\n * Sets the Meta-Information\r\n * @param {Object} metaObject\r\n */\r\nfunction setMeta(metaObject) {\r\n    meta = metaObject;\r\n}\r\n\r\n/**\r\n * Sets the DataMeta-Information\r\n * @param {Object} dataMetaObject\r\n */\r\nfunction setDataMeta(dataMetaObject) {\r\n    dataMeta = dataMetaObject;\r\n}\r\n\r\nmodule.exports.TreeNode = TreeNode;\r\nmodule.exports._NodeTypes = _NodeTypes;\r\nmodule.exports.setLogger = setLogger;\r\nmodule.exports.setCalcHelper = setCalcHelper;\r\nmodule.exports.setMeta = setMeta;\r\nmodule.exports.setDataMeta = setDataMeta;\r\n\n\n\n// WEBPACK FOOTER //\n// app/src/ui/calculationgrid/TreeNode.js","\"use strict\";\r\n/* globals CasException */\r\n\r\nvar _ = require(\"lodash\");\r\nvar _logWidgetName = \"ManualChangesSerializer\";\r\n\r\n/**\r\n *\r\n * @param dataMeta\r\n * @param {MeasureDefinitionCollection} meta\r\n * @param logger\r\n * @param {benchmark} benchmark\r\n * @constructor\r\n */\r\nvar ManualChangesSerializer = function (dataMeta, meta, logger, benchmark) {\r\n    if (logger === undefined) {\r\n        var bunyan = require('bunyan');\r\n        logger = bunyan.createLogger();\r\n    }\r\n    \r\n    /**\r\n     * @type {XMLList}\r\n     */\r\n    this.log = logger.child({widget_type: _logWidgetName});\r\n    \r\n    if (benchmark === undefined) {\r\n        benchmark = require('../benchmark');\r\n        benchmark.enable(false);\r\n    }\r\n    \r\n    /**\r\n     * @type {benchmark}\r\n     */\r\n    this.benchmark = benchmark;\r\n    \r\n    this.getDataMeta = function () {\r\n        return dataMeta;\r\n    };\r\n    \r\n    /**\r\n     * Gets the MetaInformation\r\n     * @return {MeasureDefinitionCollection}\r\n     */\r\n    this.getMeta = function () {\r\n        return meta;\r\n    };\r\n};\r\n\r\n/**\r\n * Serializes the manual changes into a minimized storable format\r\n * @param {Object[]} manualChanges\r\n * @return {{dimensions: *[], data: *[]}}\r\n */\r\nManualChangesSerializer.prototype.serialize = function (manualChanges) {\r\n    this.benchmark.startMeasurement(\"serialize\");\r\n    \r\n    var result = compressManualChanges(manualChanges, this.getDataMeta(), this.getMeta());\r\n    \r\n    this.benchmark.startMeasurement(\"serialize\");\r\n    \r\n    return result;\r\n};\r\n\r\n/**\r\n * Deserializes the minimized format of the manual changes for applying them in the tree\r\n * @param manualChanges\r\n * @return {{dimensions: Object[], data: Array}}\r\n */\r\nManualChangesSerializer.prototype.deserialize = function (manualChanges) {\r\n    this.benchmark.startMeasurement(\"serialize\");\r\n    \r\n    var deserializedDimension = translateDimensions(manualChanges.dimensions, this.getDataMeta(), this.getMeta(), this.log, this.benchmark);\r\n    \r\n    var translatedData = translateData(deserializedDimension, manualChanges.data, this.getDataMeta(), this.getMeta(), this.log, this.benchmark);\r\n    \r\n    this.benchmark.endMeasurement(\"serialize\");\r\n    \r\n    return translatedData;\r\n};\r\n\r\n/**\r\n * Indicates if the given manualChanges Object could be valid\r\n * @param {Object} manualChanges\r\n * @return {boolean}\r\n */\r\nManualChangesSerializer.prototype.isValid = function (manualChanges) {\r\n    this.benchmark.startMeasurement(\"isValid\");\r\n    \r\n    var isObject = false;\r\n    var hasArrayData = false;\r\n    var hasArrayDimensions = false;\r\n    \r\n    if (manualChanges !== undefined && manualChanges !== null && manualChanges !== \"\") {\r\n        if (typeof manualChanges === 'object') {\r\n            isObject = true;\r\n        }\r\n    }\r\n    \r\n    if (isObject && \"dimensions\" in manualChanges) {\r\n        hasArrayDimensions = Array.isArray(manualChanges.dimensions);\r\n    }\r\n    \r\n    if (isObject && \"data\" in manualChanges) {\r\n        hasArrayData = Array.isArray(manualChanges.data);\r\n    }\r\n    \r\n    this.benchmark.endMeasurement(\"isValid\");\r\n    \r\n    return (isObject && hasArrayData && hasArrayDimensions);\r\n};\r\n\r\n\r\nvar translateData = function (dimensions, data, dataMeta, meta, log, benchmark) {\r\n    benchmark.startMeasurement(\"translateData\");\r\n    \r\n    var translatedData = [];\r\n    \r\n    for (var dataIndex = 0; dataIndex < data.length; dataIndex++) {\r\n        var manualChange = {path: [], columnIndex: -1, value: undefined};\r\n        var rawPath = data[dataIndex][0];\r\n        var value = data[dataIndex][1];\r\n        var errorOccurred = false;\r\n        \r\n        for (var dimensionIndex = 0; dimensionIndex < rawPath.length; dimensionIndex++) {\r\n            var oldValue = rawPath[dimensionIndex];\r\n            var dimension = dimensions[dimensionIndex];\r\n            var translatedValue;\r\n            if (oldValue > -1) {\r\n                translatedValue = dimension.translatedValues[oldValue];\r\n            }\r\n            else {\r\n                translatedValue = -1;\r\n            }\r\n            \r\n            if (translatedValue !== undefined) {\r\n                if (dimension.axis === \"x\") {\r\n                    if (translatedValue.length == 1) {\r\n                        manualChange.columnIndex = translatedValue[0] + 1;\r\n                    }\r\n                    else {\r\n                        errorOccurred = true;\r\n                        log.error(\"Not implemented: The values on the x-axis cannot be hierarchical!\");\r\n                    }\r\n                }\r\n                else {\r\n                    manualChange.path = manualChange.path.concat(translatedValue);\r\n                }\r\n            }\r\n            else {\r\n                errorOccurred = true;\r\n                log.debug(\"Could not find value for manual change with index \" + dataIndex + \" for dimension \" + dimension.name + \". Ignoring this change!\");\r\n            }\r\n        }\r\n        \r\n        manualChange.value = value;\r\n        \r\n        if (!errorOccurred) {\r\n            translatedData.push(manualChange);\r\n        }\r\n    }\r\n    \r\n    benchmark.endMeasurement(\"translateData\");\r\n    \r\n    return translatedData;\r\n};\r\n\r\n/**\r\n *\r\n * @param {Object[]} dimensions\r\n * @param {String} dimensions[].name\r\n * @param {String} dimensions[].type\r\n * @param {Object} dataMeta\r\n * @param {MeasureDefinitionCollection} meta\r\n * @param log\r\n * @param benchmark\r\n */\r\nvar translateDimensions = function (dimensions, dataMeta, meta, log, benchmark) {\r\n    var result = [];\r\n    \r\n    for (var dimensionIndex = 0; dimensionIndex < dimensions.length; dimensionIndex++) {\r\n        var translatedDimension;\r\n        var dimension = dimensions[dimensionIndex];\r\n        \r\n        switch (dimension.type) {\r\n            case \"measure\":\r\n                translatedDimension = translateMeasureDimension(dimension, dimensionIndex, dataMeta, meta, log, benchmark);\r\n                break;\r\n            case \"time\":\r\n                translatedDimension = translateTimeDimension(dimension, dimensionIndex, dataMeta, meta, log, benchmark);\r\n                break;\r\n            case \"regular\":\r\n                translatedDimension = translateRegularDimension(dimension, dimensionIndex, dataMeta, meta, log, benchmark);\r\n                break;\r\n            default:\r\n                throw new CasException(\"Unknown dimension-type: \" + dimension.type);\r\n        }\r\n        \r\n        result[dimensionIndex] = translatedDimension;\r\n    }\r\n    //var dimension = {name: \"\", originalValues: [], translatedValues: []};\r\n    // 1) refactor dimensions\r\n    // 1.1 keep original values for backtracking/logging\r\n    \r\n    \r\n    return result;\r\n};\r\n\r\n/**\r\n *\r\n * @param {Object} oldDimension\r\n * @param {String} oldDimension.name\r\n * @param {String} oldDimension.type\r\n * @param {Object[]} oldDimension.details\r\n * @param {number} oldDimension.details.calendaryear\r\n * @param {number} oldDimension.details.week\r\n * @param {number} oldDimensionIndex\r\n * @param dataMeta\r\n * @param {MeasureDefinitionCollection} meta\r\n * @param log\r\n * @param benchmark\r\n * @return {{name: String, type: String, originalValues: Object[], originalIndex: number, translatedValues: number[], translatedIndex: number}}\r\n */\r\nvar translateTimeDimension = function (oldDimension, oldDimensionIndex, dataMeta, meta, log, benchmark) {\r\n    benchmark.startMeasurement(\"translateTimeDimension\");\r\n    var translatedDimension = {\r\n        name: oldDimension.name,\r\n        type: oldDimension.type,\r\n        originalValues: oldDimension.details,\r\n        originalIndex: oldDimensionIndex,\r\n        translatedValues: [],\r\n        translatedIndex: -1,\r\n        axis: \"\",\r\n        axisIndex: -1\r\n    };\r\n    \r\n    /**\r\n     * Transforms a timeDetailObject to a string-comparable-value\r\n     * @param {Object} timeDetail\r\n     * @param {number} timeDetail.calendaryear\r\n     * @param {number} timeDetail.week\r\n     * @return {string}\r\n     */\r\n    var timeDetailsToString = function (timeDetail) {\r\n        return timeDetail.calendaryear + \" - \" + timeDetail.week;\r\n    };\r\n    \r\n    var currentTimeDimensionIndex = _.findIndex(dataMeta.dimensions, {\"name\": oldDimension.name, \"type\": \"time\"});\r\n    if (currentTimeDimensionIndex > -1) {\r\n        var currentTimeDimension = dataMeta.dimensions[currentTimeDimensionIndex];\r\n        \r\n        translatedDimension.translatedIndex = currentTimeDimensionIndex;\r\n        \r\n        var translatedValueKeys = toValueKeyCollection(currentTimeDimension.details, timeDetailsToString);\r\n        \r\n        var translatedValues = [];\r\n        for (var oldDetailsIndex = 0; oldDetailsIndex < oldDimension.details.length; oldDetailsIndex++) {\r\n            var oldTimeDetails = oldDimension.details[oldDetailsIndex];\r\n            if(oldTimeDetails === -1) {\r\n                translatedValues[oldDetailsIndex] = [-1];    // TOTAL value\r\n            } else {\r\n                var comparableString = timeDetailsToString(oldTimeDetails);\r\n                var currentIndex = translatedValueKeys[comparableString];\r\n                \r\n                if (currentIndex !== undefined) {\r\n                    translatedValues[oldDetailsIndex] = [currentIndex];\r\n                }\r\n                else {\r\n                    log.info(\"The entry '\" + comparableString + \"' in dimension '\" + oldDimension.name + \"' is no longer valid and will be ignored.\");\r\n                }\r\n            }\r\n        }\r\n        \r\n        translatedDimension.translatedValues = translatedValues;\r\n        translatedDimension.axis = getAxisOfDimension(oldDimension.name, meta, log, benchmark);\r\n        \r\n    } else {\r\n        throw new CasException(\"Could not find the oldDimension with the name \" + oldDimension.name + \" of type 'time'\");\r\n    }\r\n    \r\n    //  1b) time => match week + year -> to new []internalNodeId (remember totalValue +1), if not present null) -> timeframe no longer valid -> will be ignoring these changes\r\n    \r\n    benchmark.endMeasurement(\"translateTimeDimension\");\r\n    \r\n    return translatedDimension;\r\n};\r\n\r\n/**\r\n *\r\n * @param dimensionName\r\n * @param meta\r\n * @param log\r\n * @param benchmark\r\n * @return {string}\r\n */\r\nvar getAxisOfDimension = function (dimensionName, meta, log, benchmark) {\r\n    benchmark.startMeasurement(\"getAxisOfDimension\");\r\n    \r\n    var axis = \"\";\r\n    \r\n    if (meta.axis.x === dimensionName) {\r\n        axis = \"x\";\r\n    }\r\n    else {\r\n        var dimensionIndex = _.findIndex(meta.axis.y, function (dimName) {\r\n            return (dimensionName === dimName);\r\n        });\r\n        \r\n        if (dimensionIndex > -1) {\r\n            axis = \"y\";\r\n        } else {\r\n            log.warn(\"The dimension with the name '\" + dimensionName + \"' is no longer used and will be ignored!\");\r\n        }\r\n    }\r\n    \r\n    benchmark.endMeasurement(\"getAxisOfDimension\");\r\n    \r\n    return axis;\r\n};\r\n\r\n/**\r\n *\r\n * @param {Object} oldDimension\r\n * @param {String} oldDimension.name\r\n * @param {String} oldDimension.type\r\n * @param {String[]} oldDimension.lookups\r\n * @param {number} dimensionIndex\r\n * @param dataMeta\r\n * @param {MeasureDefinitionCollection} meta\r\n * @param log\r\n * @param benchmark\r\n * @return {{name: String, type: String, originalValues: String[], originalIndex: number, translatedValues: number[], translatedIndex: number}}\r\n */\r\nvar translateMeasureDimension = function (oldDimension, dimensionIndex, dataMeta, meta, log, benchmark) {\r\n    benchmark.startMeasurement(\"translateMeasureDimension\");\r\n    var translatedDimension = {\r\n        name: oldDimension.name,\r\n        type: oldDimension.type,\r\n        originalValues: oldDimension.lookups,\r\n        originalIndex: dimensionIndex,\r\n        translatedValues: [],\r\n        translatedIndex: -1,\r\n        axis: \"\",\r\n        axisIndex: -1\r\n    };\r\n    \r\n    var currentMeasureDimensionIndex = _.findIndex(dataMeta.dimensions, {\"type\": \"measure\"});\r\n    if (currentMeasureDimensionIndex > -1) {\r\n        var currentMeasureDimension = dataMeta.dimensions[currentMeasureDimensionIndex];\r\n        \r\n        translatedDimension.translatedIndex = currentMeasureDimensionIndex;\r\n        \r\n        var translatedValueKeys = meta.editableCodeIndexMapping;\r\n        \r\n        var translatedValues = [];\r\n        for (var oldLookUpIndex = 0; oldLookUpIndex < oldDimension.lookups.length; oldLookUpIndex++) {\r\n            var oldEditableCode = oldDimension.lookups[oldLookUpIndex];\r\n            var currentIndex = translatedValueKeys[oldEditableCode];\r\n            \r\n            if (currentIndex !== undefined) {\r\n                translatedValues[oldLookUpIndex] = [currentIndex];\r\n            }\r\n            else {\r\n                log.info(\"The measure with the editable code '\" + oldEditableCode + \"' in dimension '\" + currentMeasureDimension.name + \"' is no longer valid and will be ignored.\");\r\n            }\r\n        }\r\n        \r\n        translatedDimension.translatedValues = translatedValues;\r\n        translatedDimension.axis = getAxisOfDimension(\"measures\", meta, log, benchmark);\r\n        \r\n    } else {\r\n        throw new CasException(\"Could not find the the dimension of type 'measure'\");\r\n    }\r\n    \r\n    benchmark.endMeasurement(\"translateMeasureDimension\");\r\n    \r\n    return translatedDimension;\r\n};\r\n\r\n/**\r\n * This callback type is called when a conversion of any type to a string should be done\r\n *\r\n * @callback toStringCallback\r\n * @param {*} input\r\n * @return {string}\r\n */\r\n\r\n/**\r\n *\r\n * @param {Array} keyValueCollection\r\n * @param {toStringCallback} [toString]\r\n * @return {{}}\r\n */\r\nvar toValueKeyCollection = function (keyValueCollection, toString) {\r\n    if (!isFunction(toString)) {\r\n        toString = defaultToStringFunction;\r\n    }\r\n    \r\n    var result = {};\r\n    \r\n    for (var index = 0; index < keyValueCollection.length; index++) {\r\n        result[toString(keyValueCollection[index])] = index;\r\n    }\r\n    \r\n    return result;\r\n};\r\n\r\n/**\r\n * Returns the same value as result\r\n * @param {string} input\r\n * @return {string}\r\n */\r\nvar defaultToStringFunction = function (input) {\r\n    return input;\r\n};\r\n\r\n/**\r\n * Checks if the given argument is a function.\r\n * @function\r\n * @private\r\n */\r\nvar isFunction = function (func) {\r\n    return (typeof func) === 'function';\r\n};\r\n\r\n/**\r\n *\r\n * @param {Object} oldDimension\r\n * @param {String} oldDimension.name\r\n * @param {String} oldDimension.type\r\n * @param {String[]} oldDimension.lookups\r\n * @param {number} dimensionIndex\r\n * @param dataMeta\r\n * @param {MeasureDefinitionCollection} meta\r\n * @param log\r\n * @param benchmark\r\n * @return {{name: String, type: String, originalValues: String[], originalIndex: number, translatedValues: number[], translatedIndex: number}}\r\n */\r\nvar translateRegularDimension = function (oldDimension, dimensionIndex, dataMeta, meta, log, benchmark) {\r\n    benchmark.startMeasurement(\"translateRegularDimension\");\r\n    var translatedDimension = {\r\n        name: oldDimension.name,\r\n        type: oldDimension.type,\r\n        originalValues: oldDimension.lookups,\r\n        originalIndex: dimensionIndex,\r\n        translatedValues: [],\r\n        translatedIndex: -1,\r\n        axis: \"\",\r\n        axisIndex: -1\r\n    };\r\n    \r\n    var currentDimensionIndex = _.findIndex(dataMeta.dimensions, {\"name\": oldDimension.name, \"type\": \"regular\"});\r\n    if (currentDimensionIndex > -1) {\r\n        var currentDimension = dataMeta.dimensions[currentDimensionIndex];\r\n        \r\n        translatedDimension.translatedIndex = currentDimensionIndex;\r\n        \r\n        var translatedValueKeys = {};\r\n        resolveHierarchicalLookUps(translatedValueKeys, currentDimension);\r\n        \r\n        var translatedValues = [];\r\n        for (var oldLookUpIndex = 0; oldLookUpIndex < oldDimension.lookups.length; oldLookUpIndex++) {\r\n            var compareString = oldDimension.lookups[oldLookUpIndex];\r\n            var currentPath = translatedValueKeys[compareString];\r\n            \r\n            if (currentPath !== undefined) {\r\n                translatedValues[oldLookUpIndex] = currentPath;\r\n            }\r\n            else {\r\n                log.info(\"The entry '\" + compareString + \"' in dimension '\" + oldDimension.name + \"' is no longer valid and will be ignored.\");\r\n            }\r\n        }\r\n        \r\n        translatedDimension.translatedValues = translatedValues;\r\n        translatedDimension.axis = getAxisOfDimension(oldDimension.name, meta, log, benchmark);\r\n        \r\n    }\r\n    else {\r\n        log.warn(\"Could not find the dimension with the name '\" + oldDimension.name + \"' of type 'regular'. This could lead to invalid results!\");\r\n    }\r\n    \r\n    //  1c) regular => match id with id -> to new []internalNodeId + hierarchy if necessary + -1 if currently is -1 (Tactic) -> no validation! + log info\r\n    \r\n    benchmark.endMeasurement(\"translateRegularDimension\");\r\n    \r\n    return translatedDimension;\r\n};\r\n\r\nvar resolveHierarchicalLookUps = function (translatedValues, hierarchyInformation) {\r\n    \r\n    var hasParentInHierarchy = (hierarchyInformation.hierarchy !== undefined);\r\n    if (hasParentInHierarchy) {\r\n        resolveHierarchicalLookUps(translatedValues, hierarchyInformation.hierarchy);\r\n    }\r\n    \r\n    for (var i = 0; i < hierarchyInformation.lookups.length; i++) {\r\n        var ownId = hierarchyInformation.lookups[i];\r\n        \r\n        if (hasParentInHierarchy) {\r\n            var parentLookUpIndex = hierarchyInformation.hierarchy.mapping[i];\r\n            var parentLookUpValue = hierarchyInformation.hierarchy.lookups[parentLookUpIndex];\r\n            var parentPath = translatedValues[parentLookUpValue].slice();\r\n            parentPath.push(i);\r\n            \r\n            translatedValues[ownId] = parentPath;\r\n        }\r\n        else {\r\n            translatedValues[ownId] = [i];\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n *\r\n * @param {Object[]} manualChanges\r\n * @param dataMeta\r\n * @param meta\r\n * @return {{dimensions: [], data: *[]}}\r\n */\r\nvar compressManualChanges = function (manualChanges, dataMeta, meta) {\r\n    var compressedChanges = {dimensions: [], data: []};\r\n    \r\n    var dimensionNameLookupResolution = {dimensionCounter: 0, dimensions: {}};\r\n    \r\n    for (var changeIndex = 0; changeIndex < manualChanges.length; changeIndex++) {\r\n        var manualChange = manualChanges[changeIndex];\r\n        var manualRecord = [[], manualChange.value];\r\n        \r\n        for (var dimensionName in manualChange.dimensions) {\r\n            if (manualChange.dimensions.hasOwnProperty(dimensionName)) {\r\n                var dimensionValue = manualChange.dimensions[dimensionName];\r\n                \r\n                manualRecord[0].push(resolveDimensionLookupIndex(dimensionNameLookupResolution, dimensionName, dimensionValue));\r\n            }\r\n        }\r\n        \r\n        compressedChanges.data.push(manualRecord);\r\n    }\r\n    \r\n    compressedChanges.dimensions = correctDimensionLookup(dimensionNameLookupResolution, dataMeta, meta);\r\n    \r\n    return compressedChanges;\r\n};\r\n\r\n/**\r\n * @param {Object} dimensionInformation\r\n * @param {Number} dimensionInformation.dimensionCounter\r\n * @param {Object} dimensionInformation.dimensions\r\n * @param {string} dimensionName\r\n * @param {string} itemName\r\n */\r\nvar resolveDimensionLookupIndex = function (dimensionInformation, dimensionName, itemName) {\r\n    if (!(dimensionName in dimensionInformation.dimensions)) {\r\n        dimensionInformation.dimensions[dimensionName] = {\r\n            lookups: [],\r\n            resolution: {},\r\n            dimensionId: dimensionInformation.dimensionCounter++,\r\n            dimensionName: dimensionName\r\n        };\r\n    }\r\n    \r\n    var dimensionInfo = dimensionInformation.dimensions[dimensionName];\r\n    \r\n    if (!(itemName in dimensionInfo.resolution)) {\r\n        dimensionInfo.resolution[itemName] = dimensionInfo.lookups.length;\r\n        dimensionInfo.lookups.push(itemName);\r\n    }\r\n    \r\n    return dimensionInfo.resolution[itemName];\r\n};\r\n\r\n/**\r\n *\r\n * @param {Object} dimensionInformation\r\n * @param {Number} dimensionInformation.dimensionCounter\r\n * @param {Object} dimensionInformation.dimensions\r\n * @param dataMeta\r\n * @param meta\r\n * @return {Object[]}\r\n */\r\nvar correctDimensionLookup = function (dimensionInformation, dataMeta, meta) {\r\n    var reducedDimensionInformation = [];\r\n    \r\n    for (var dimensionName in dimensionInformation.dimensions) {\r\n        var dimensionObject = dimensionInformation.dimensions[dimensionName];\r\n        var correctedDimensionObject = dimensionObject;\r\n        var dimensionMeta;\r\n        if (dimensionName !== \"measures\") {\r\n            dimensionMeta = _.find(dataMeta.dimensions, {\"name\": dimensionName});\r\n        }\r\n        else {\r\n            dimensionMeta = _.find(dataMeta.dimensions, {\"type\": \"measure\"});\r\n        }\r\n        \r\n        if (dimensionMeta.type === \"time\") {\r\n            correctedDimensionObject = correctTimeDimensionInformation(dimensionObject, dimensionMeta, meta);\r\n        }\r\n        else if (dimensionMeta.type === \"measure\") {\r\n            correctedDimensionObject = correctMeasureDimensionInformation(dimensionObject, dimensionMeta, meta);\r\n        }\r\n        else if (dimensionMeta.type === \"regular\") {\r\n            correctedDimensionObject = correctRegularDimensionInformation(dimensionObject, dimensionMeta, meta);\r\n        }\r\n        else {\r\n            throw new CasException(\"Unknown DimensionType: \" + dimensionMeta.type);\r\n        }\r\n        \r\n        reducedDimensionInformation[dimensionObject.dimensionId] = correctedDimensionObject;\r\n    }\r\n    \r\n    return reducedDimensionInformation;\r\n};\r\n\r\n/**\r\n *\r\n * @param {Object} dimensionObject\r\n * @param {String} dimensionObject.dimensionName\r\n * @param {number} dimensionObject.dimensionId\r\n * @param {Object} dimensionObject.resolution\r\n * @param {String[]} dimensionObject.lookups\r\n * @param dimensionMeta\r\n * @param meta\r\n * @return {{name: string, type: string, details: Array}}\r\n */\r\nvar correctTimeDimensionInformation = function (dimensionObject, dimensionMeta, meta) {\r\n    var correctedDimensionInformation = {name: dimensionMeta.name, type: \"time\", details: []};\r\n    \r\n    for (var lookUpIndex = 0; lookUpIndex < dimensionObject.lookups.length; lookUpIndex++) {\r\n        var weekIndex = dimensionObject.lookups[lookUpIndex] - 1;   // total correction\r\n        if(weekIndex < 0) {\r\n            correctedDimensionInformation.details[lookUpIndex] = -1;    // TOTAL VALUE!\r\n        } else {\r\n            correctedDimensionInformation.details[lookUpIndex] = dimensionMeta.details[weekIndex];\r\n        }\r\n    }\r\n    \r\n    return correctedDimensionInformation;\r\n};\r\n\r\n/**\r\n *\r\n * @param {Object} dimensionObject\r\n * @param {String} dimensionObject.dimensionName\r\n * @param {number} dimensionObject.dimensionId\r\n * @param {Object} dimensionObject.resolution\r\n * @param {String[]} dimensionObject.lookups\r\n * @param dimensionMeta\r\n * @param meta\r\n */\r\nvar correctMeasureDimensionInformation = function (dimensionObject, dimensionMeta, meta) {\r\n    var correctedDimensionInformation = {name: dimensionMeta.name, type: \"measure\", lookups: []};\r\n    \r\n    for (var measureIndex = 0; measureIndex < meta.measures.length; measureIndex++) {\r\n        var measureDefinition = meta.measures[measureIndex];\r\n        if (measureDefinition.name in dimensionObject.resolution) {\r\n            var lookupIndex = dimensionObject.resolution[measureDefinition.name];\r\n            correctedDimensionInformation.lookups[lookupIndex] = measureDefinition.distributionInformation.code;\r\n        }\r\n    }\r\n    \r\n    return correctedDimensionInformation;\r\n};\r\n\r\n/**\r\n *\r\n * @param {Object} dimensionObject\r\n * @param {String} dimensionObject.dimensionName\r\n * @param {number} dimensionObject.dimensionId\r\n * @param {Object} dimensionObject.resolution\r\n * @param {String[]} dimensionObject.lookups\r\n * @param dimensionMeta\r\n * @param meta\r\n * @return {{name: (string|*|String), type: string, lookups: *}}\r\n */\r\nvar correctRegularDimensionInformation = function (dimensionObject, dimensionMeta, meta) {\r\n    var correctedDimensionInformation = {\r\n        name: dimensionObject.dimensionName,\r\n        type: \"regular\",\r\n        lookups: dimensionObject.lookups\r\n    };\r\n    \r\n    return correctedDimensionInformation;\r\n};\r\n\r\nmodule.exports.ManualChangesSerializer = ManualChangesSerializer;\r\n\n\n\n// WEBPACK FOOTER //\n// app/src/ui/calculationgrid/ManualChangesSerializer.js","\"use strict\";\r\n\r\n/**\r\n *\r\n * @constructor\r\n * @public\r\n */\r\nvar CalculationVariableParser = function () {\r\n    \r\n};\r\n\r\n/**\r\n *\r\n * @type {null|Object}\r\n * @memberOf CalculationVariableParser\r\n * @private\r\n */\r\nCalculationVariableParser.prototype._logger = null;\r\n\r\n/**\r\n *\r\n * @type {benchmark}\r\n * @memberOf CalculationVariableParser\r\n * @private\r\n */\r\nCalculationVariableParser.prototype.benchmark = null;\r\n\r\n/**\r\n *\r\n * @type {null|Object}\r\n * @memberOf CalculationVariableParser\r\n * @private\r\n */\r\nCalculationVariableParser.prototype.log = null;\r\n\r\n\r\n/**\r\n *\r\n * @param logger\r\n * @memberOf CalculationVariableParser\r\n * @public\r\n */\r\nCalculationVariableParser.prototype.setLogger = function(logger) {\r\n    this._logger = logger;\r\n    this.log = logger.child({widget_type: 'CalculationVariableParser'});\r\n};\r\n\r\n/**\r\n *\r\n * @param {benchmark} benchmark\r\n * @memberOf CalculationVariableParser\r\n * @public\r\n */\r\nCalculationVariableParser.prototype.setBenchmark = function(benchmark) {\r\n    this.benchmark = benchmark;\r\n};\r\n\r\n\r\n/**\r\n * Parses all variables\r\n *\r\n * @param {Object} calculationVariables\r\n * @memberOf CalculationVariableParser\r\n * @public\r\n */\r\nCalculationVariableParser.prototype.parse = function(calculationVariables) {\r\n    this.benchmark.startMeasurement(\"CalculationVariableParser.parse()\");\r\n    \r\n    for(var dimensionName in calculationVariables) {\r\n        if(calculationVariables.hasOwnProperty(dimensionName)) {\r\n            var dimension = calculationVariables[dimensionName];\r\n            \r\n            this.parseDimension(dimension);\r\n        }\r\n    }\r\n    \r\n    this.benchmark.endMeasurement(\"CalculationVariableParser.parse()\");\r\n};\r\n\r\n/**\r\n * Parses each member of the given dimension\r\n *\r\n * @param {Object} dimension\r\n * @memberOf CalculationVariableParser\r\n * @private\r\n */\r\nCalculationVariableParser.prototype.parseDimension = function(dimension) {\r\n    for(var dimensionMemberName in dimension) {\r\n        if(dimension.hasOwnProperty(dimensionMemberName)) {\r\n            var dimensionMember = dimension[dimensionMemberName];\r\n            \r\n            this.parseDimensionItem(dimensionMember);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Parses each attribute of the given dimension member\r\n *\r\n * @param {Object} dimensionMember\r\n * @memberOf CalculationVariableParser\r\n * @private\r\n */\r\nCalculationVariableParser.prototype.parseDimensionItem = function(dimensionMember) {\r\n    for(var attributeName in dimensionMember) {\r\n        if(dimensionMember.hasOwnProperty(attributeName)) {\r\n            \r\n            if(typeof dimensionMember[attributeName] === \"string\") {\r\n                this.parseAttributeTypeString(dimensionMember, attributeName);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Parses an attribute of type String\r\n *\r\n * If the string starts with '{' and ends with '}', the value is assumed to be of type Object and will be parsed as such\r\n *\r\n * @param {Object} dimensionItem\r\n * @param {String} attributeName\r\n * @memberOf CalculationVariableParser\r\n * @private\r\n */\r\nCalculationVariableParser.prototype.parseAttributeTypeString = function(dimensionItem, attributeName) {\r\n    var attribute = dimensionItem[attributeName];\r\n    \r\n    if(attribute.length >= 2) {\r\n        if(attribute[0] === \"{\" && attribute[attribute.length - 1] === \"}\") {\r\n            try {\r\n                attribute = JSON.parse(attribute);\r\n            } catch(ex) {\r\n                attribute = {};\r\n                this.log.warn(\"Could not parse the attribute '\" + attributeName + \"'. Using fallback empty Object.\");\r\n                this.log.debug(\"Parsing the attribute '\" + attributeName + \"' caused the following exception: \" + ex);\r\n            }\r\n            \r\n            dimensionItem[attributeName] = attribute;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports.CalculationVariableParser = CalculationVariableParser;\r\n\n\n\n// WEBPACK FOOTER //\n// app/src/ui/calculationgrid/CalculationVariableParser.js"],"mappings":";;;;;AAAA;AACA;AAEA;AACA;;;;;;;;;ACJA;AACA;;;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAAA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAXA;AAAA;AAAA;AACA;AADA;AAYA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAiBA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AACA;AADA;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAHA;AAAA;AAAA;AACA;AADA;AAIA;AAAA;AACA;AAAA;AACA;AACA;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAmBA;AAAA;AACA;AAAA;AACA;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuBA;AAjCA;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AACA;AADA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AAHA;AAAA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/SA;AACA;AAiTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;;;;;;;;;ACxUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AACA;AAQA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;;;;;;;AC94BA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AACA;AAgBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;;;;;;AAMA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAcA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAIA;;;;;;;;;AC1sBA;;;;AAIA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AAQA;;;;;;;AChHA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AACA;;;;;AAKA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AACA;AAYA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AACA;AAaA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;;;;;;;AAOA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAEA;AACA;;;;;;;;AC/dA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;;AAOA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhDA;AACA;AAkDA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC30CA;AACA;AACA;;;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AACA;AAUA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;;;;;;;;AC1qBA;AACA;AACA;;;;;;AAKA;AACA;AAGA;;;;;;AAMA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;AAMA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;","sourceRoot":""}